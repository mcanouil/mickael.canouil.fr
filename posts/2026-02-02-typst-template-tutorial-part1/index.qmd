---
title: "Building Quarto Typst Templates: The Lua-Typst Bridge (Part 1)"
subtitle: "Part 1"
description: |
  This tutorial introduces the dual-layer architecture for building Quarto Typst templates.
  You will learn how Lua filters and Typst functions work together to transform markdown elements into styled PDF components.
date: "2026-02-02"
categories:
  - quarto
  - extensions
  - typst
  - lua
  - pdf
image: featured.png
image-alt: |
  Feature image for "Quarto + Typst Part 1" blog post.
  Dark background with the official Quarto logo (four blue quadrants with wordmark) and Typst logo (teal wordmark) centered at the top.
  Below, "Part 1" in serif font with subtitle "Modern Scientific Publishing".
  File format pipeline shows .qmd → .typ → .pdf.
  Decorative elements include floating code snippets and gradient orbs in blue and teal.
lang: en-GB
number-sections: true
link-external-newwindow: true
lightbox: true
draft: true
---

![](featured.png){
  .img-featured
  .img-fluid
  fig-align="center"
  fig-alt='{{< meta image-alt >}}'
  width="600px"
}

## Why PDF Branding Matters

In professional environments, document presentation is not merely aesthetic; it is a reflection of organisational identity and credibility.
Whether you are producing academic papers, corporate reports, client proposals, or technical documentation, consistent branding transforms disparate documents into a cohesive portfolio that reinforces trust and recognition.

Yet achieving this consistency manually is fraught with challenges.
Copy-pasting styles between documents introduces errors.
Updating a colour scheme across dozens of files becomes a maintenance nightmare.
And when multiple team members contribute to documents, stylistic drift is inevitable.

:::: {.highlight}

**Reproducible branding** through code eliminates manual styling errors and ensures every document reflects your organisation's identity automatically.

:::

This is where programmatic document styling becomes valuable.

Typst offers a modern, programmable alternative to LaTeX for PDF generation.
Its syntax is cleaner, compilation is faster, and its scripting capabilities make complex layouts achievable without the arcane incantations that LaTeX often requires.
When paired with Quarto's publishing ecosystem, Typst becomes a powerful foundation for branded document production.

## Prior Art: Getting Started with Typst and Quarto

Before diving into advanced techniques, it is worth acknowledging excellent foundational resources recently published.
David Keyes wrote a comprehensive introduction to using Typst with Quarto at [R for the Rest of Us](https://rfortherestofus.com/2025/11/quarto-typst-pdf).
If you are new to Typst or want a gentler introduction, that post provides an excellent starting point.

This tutorial builds upon that foundation.
Where David's post shows how to use Typst templates with Quarto, this tutorial explores how to _build_ sophisticated templates that pair Lua filters with Typst rendering functions.
What does this mean in practice?
It means creating reusable components like badges, panels, and card grids that authors can invoke with simple markdown syntax instead of writing Typst code directly.

In this tutorial, you will learn the architectural patterns that enable rich, interactive components whilst maintaining clean, extensible code.

:::: {.callout-note}

This is **Part 1** of a two-part series.
This part covers the foundational concepts; [Part 2](/posts/2026-03-02-typst-template-tutorial-part2/) explores advanced patterns including handler factories, complex components, and configuration systems.

The examples here are generic, but the ['mcanouil' Quarto extension](https://github.com/mcanouil/quarto-mcanouil) demonstrates these patterns in a production context.

:::

## The Problem: Bridging Markdown and Typst

Consider a simple scenario: you want users to write badges in their Quarto documents using familiar markdown syntax, but have them render as styled components in Typst.

```markdown
The task is [Completed]{.badge colour="success"} and ready for review.
```

This should produce a styled badge in the PDF output.
But here is the challenge: Typst templates alone cannot intercept and transform markdown elements.
Typst receives content _after_ Quarto and Pandoc have processed it, so by the time your template sees the document, that `.badge` span has already been converted to plain text.

The solution requires two layers working in concert:

1. **Lua filters** that intercept markdown elements during Pandoc processing and generate Typst code.
2. **Typst functions** that receive that generated code and render styled output.

The transformation looks like this:

```{mermaid}
%%| label: fig-bridge
%%| fig-cap: "The bridge between markdown and Typst."
%%| fig-alt: "Diagram showing the transformation of markdown syntax `[Completed]{.badge colour='success'}` through Pandoc AST processing by Lua filter into Typst code `#my-badge(colour: 'success')[Completed]` which is then rendered by Typst function into a styled badge component."
flowchart LR
    A["[Completed]{.badge colour='success'}"] --> B[Pandoc AST]
    B --> C[Lua Filter]
    C --> D["#my-badge(colour: 'success')[Completed]"]
    D --> E[Typst Function]
    E --> F[Styled Badge]
```

## The Dual-Layer Architecture

This tutorial explores a dual-layer architecture where Lua handles document transformation and Typst handles rendering.

### Layer 1: Document Processing (Lua)

Lua filters operate on Pandoc's Abstract Syntax Tree (AST), the intermediate representation of your document after Quarto parses the markdown.
At this stage, you can:

- Identify elements by their classes (_e.g._, `.badge`, `.panel`).
- Extract attributes (_e.g._, `colour="success"`).
- Generate raw Typst code to replace those elements.

The key Pandoc functions for this bridge are:

```{.lua filename="Lua"}
-- For block-level elements (divs, paragraphs)
pandoc.RawBlock('typst', '#my-function[content]') -- <1>

-- For inline elements (spans, text)
pandoc.RawInline('typst', '#my-function[content]') -- <2>
```

1. Creates a block-level raw element; see [Pandoc Lua types](https://pandoc.org/lua-filters.html#type-rawblock).
2. Creates an inline raw element; see [Pandoc Lua types](https://pandoc.org/lua-filters.html#type-rawinline).

These functions tell Pandoc to pass the string directly to Typst without further processing.

### Layer 2: Template Rendering (Typst)

On the Typst side, you define functions that receive the generated code and produce styled output.
These functions have access to:

- The document's colour scheme and typography settings.
- Page dimensions and layout context.
- Typst's full styling capabilities.

A simple Typst function might look like:

```{.typst filename="Typst"}
#let my-badge(content, colour: "neutral") = { // <1>
  box( // <2>
    fill: luma(230), // <3>
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, content)
  )
}
```

1. Function definition with content parameter and optional named parameter.
2. [`box`](https://typst.app/docs/reference/layout/box/) creates an inline container.
3. [`luma`](https://typst.app/docs/reference/visualize/color/#definitions-luma) creates a greyscale colour (0-255).

### Why This Separation?

This dual-layer approach offers several advantages:

- **Separation of concerns**: Lua handles "what to transform", Typst handles "how to render".
- **Flexibility**: Change the rendering without touching the transformation logic, or vice versa.
- **Testability**: Each layer can be developed and tested independently.
- **Reusability**: Typst functions can be called directly in Typst code, not just through the Lua bridge.

## Extension Structure Overview

Before diving into component implementation, let us establish the minimal file organisation needed for a Typst extension.

```txt
_extensions/my-extension/
├── _extension.yml       # Extension manifest
├── template.typ         # Main Typst template
├── typst-show.typ       # Wrapper functions for components
├── components.typ       # Component rendering functions
└── filter.lua           # Lua filter for element transformation
```

The `_extension.yml` manifest declares how these pieces fit together:

```{.yaml filename="_extension.yml"}
title: My Extension
version: 1.0.0
contributes:
  formats:
    typst:
      template: template.typ
      template-partials:
        - typst-show.typ
        - components.typ
      filters:
        - filter.lua
```

:::: {.highlight}

Production extensions like [quarto-mcanouil](https://github.com/mcanouil/quarto-mcanouil) use more elaborate structures with shared modules and component libraries.
Part 2 covers those architectural patterns.

:::

With this foundation established, we can now explore how to build components, starting with simple inline badges and progressing to block-level panels.

## First Component: Badges (Inline Elements)

Badges are compact inline indicators, perfect for showing status, categories, or tags.
They represent the simplest component type: a span element with optional attributes that transforms into a styled box.

### Understanding Pandoc Span Elements

When you write `[Completed]{.badge colour="success"}` in your Quarto document, Pandoc parses this into a Span element in its AST.
The Span contains:

- **`span.content`**: The text content ("Completed").
- **`span.classes`**: A list of classes (["badge"]).
- **`span.attributes`**: A table of key-value pairs ({colour = "success"}).

A Lua filter can inspect these properties and decide how to transform the element.

### Building the Typst Function: Start Simple

Let us begin with the simplest possible badge function in Typst:

```{.typst filename="badges.typ (v1 - minimal)"}
#let simple-badge(content) = {
  box(
    fill: luma(230),
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, content)
  )
}
```

This creates a grey box with rounded corners around any content.
It works, but it lacks colour customisation and accessibility considerations.

### Adding Colour Support

Next, let us add colour support with predefined semantic colours:

```{.typst filename="badges.typ (v2 - with colours)"}
#let get-badge-colour(colour-name) = {
  if colour-name == "success" { rgb("#009955") }
  else if colour-name == "warning" { rgb("#cc6600") }
  else if colour-name == "danger" { rgb("#cc0000") }
  else if colour-name == "info" { rgb("#0066cc") }
  else { luma(128) }  // neutral default
}

#let simple-badge(content, colour: "neutral") = {
  let base = get-badge-colour(colour)
  box(
    fill: base.lighten(80%),
    stroke: 0.5pt + base.lighten(40%),
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, fill: base, content)
  )
}
```

Now users can specify `colour: "success"` and get a green badge.

### Building the Lua Handler

With the Typst function ready, we need a Lua handler to generate calls to it.
Here is the simplest approach:

```{.lua filename="badges.lua (v1 - minimal)"}
function Span(span) -- <1>
  -- Only process spans with the 'badge' class
  if not span.classes:includes('badge') then -- <2>
    return span
  end

  -- Extract content as plain text
  local content = pandoc.utils.stringify(span.content) -- <3>

  -- Get the colour attribute (default to neutral)
  local colour = span.attributes.colour or 'neutral' -- <4>

  -- Generate Typst function call
  local typst_code = string.format( -- <5>
    '#simple-badge(colour: "%s")[%s]',
    colour,
    content
  )

  return pandoc.RawInline('typst', typst_code) -- <6>
end
```

1. [Span filter function](https://pandoc.org/lua-filters.html#type-span) receives each span element.
2. Check if span has the target class; return unchanged if not.
3. [`stringify`](https://pandoc.org/lua-filters.html#pandoc.utils.stringify) converts AST content to plain text.
4. Access attributes as a Lua table; provide default value.
5. Build the Typst function call string with parameters.
6. Return raw Typst code that Pandoc passes through unchanged.

This works for our simple use case.
The Lua filter checks if a span has the `badge` class, extracts its content and attributes, and generates a Typst function call.

### The Wrapper Function: Injecting Runtime Colours

There is one more piece to the puzzle.
The Typst rendering function needs access to the document's colour scheme, but Lua generates code at parse time before colours are resolved.
The solution is a **wrapper function** in `typst-show.typ`.

:::: {.callout-tip}

## Quarto Template Syntax

Quarto's Typst partials use Pandoc template syntax for variable interpolation:

- `$variable$` inserts a metadata value.
- `$if(variable)$...$endif$` conditionally includes content.
- `$if(variable)$...$else$...$endif$` provides a fallback value.

These are resolved at render time, not parse time.
See [Typst partials](https://quarto.org/docs/journals/templates.html#typst-partials) for details.

:::

```{.typst filename="typst-show.typ"}
// Define brand mode with default fallback
#let effective-brand-mode = "$if(brand-mode)$$brand-mode$$else$light$endif$" // <1>

// Wrapper for .badge spans - injects colours at render time
#let my-badge(content, colour: "neutral") = { // <2>
  simple-badge(
    content,
    colour: colour,
    colours: get-colours(mode: effective-brand-mode) // <3>
  )
}
```

1. Quarto template syntax (`$if()$`) resolves at render time; see [Typst partials](https://quarto.org/docs/journals/templates.html#typst-partials).
2. Wrapper function receives the same parameters as the Lua filter generates.
3. Inject the colour scheme based on current brand mode (light/dark).

The Lua filter generates `#my-badge(colour: "success")[Completed]`.
At render time, `my-badge` calls `simple-badge` with the appropriate colour scheme.

:::: {.highlight}

**Wrapper functions** bridge the gap between parse-time code generation (Lua) and render-time colour resolution (Typst).
They inject runtime context that Lua cannot know in advance.

:::

## Block Components: Panels (Wrapped Content)

Badges are inline elements with simple text content.
Panels are block elements that can contain rich, nested content: paragraphs, lists, images, even code blocks.
This introduces a new challenge: how do we preserve and pass through complex content whilst still wrapping it in our Typst function?

### Understanding Pandoc Div Elements

When you write a fenced div in Quarto:

```markdown
::: {.panel style="info" title="Important Note"}
This panel contains **rich content** including:

- Bullet points.
- _Formatted text_.
- And more.
  :::
```

Pandoc parses this into a Div element with:

- **`div.content`**: An array of block elements (paragraphs, lists, etc.).
- **`div.classes`**: A list of classes (["panel"]).
- **`div.attributes`**: A table of key-value pairs.

The critical difference from spans: `div.content` is not simple text but a list of Pandoc AST nodes that need further processing.

### The Wrapped Content Pattern

Unlike badges where we convert content to plain text, panels need to preserve their content structure.
The solution is to wrap the content with opening and closing Typst code:

```{.lua filename="Conceptual pattern"}
-- Instead of: #panel[plain text]
-- We generate:
-- #panel(style: "info")[
--   <original content passes through>
-- ]

local result = {
  pandoc.RawBlock('typst', '#my-panel(style: "info")['),  -- Opening
  -- Original div.content elements go here
  pandoc.RawBlock('typst', ']')  -- Closing
}
```

This approach lets Pandoc continue processing the inner content (converting markdown to Typst), whilst our wrapper provides the styling context.

### Building the Wrapped Content Handler

The wrapper module provides utilities for this pattern:

```{.lua filename="wrapper.lua"}
--- Build Typst block wrappers with optional attributes
local function build_typst_block_wrappers(config, attrs)
  local has_attributes = next(attrs) ~= nil
  local should_pass = config.arguments or has_attributes

  if should_pass and has_attributes then
    local attr_string = build_attribute_string(attrs)
    return string.format('#%s(%s)[', config.wrapper, attr_string), ']' -- <1>
  else
    return string.format('#%s[', config.wrapper), ']'
  end
end

--- Build wrapped content for components
local function build_wrapped_content(div, config, extract_title)
  local attrs = attributes_to_table(div)

  -- Optionally extract first heading as title attribute
  if extract_title then
    extract_first_heading_as_title(div, attrs) -- <2>
  end

  local opening, closing = build_typst_block_wrappers(config, attrs)

  -- Build result: opening wrapper, content, closing wrapper
  local result = { pandoc.RawBlock('typst', opening) } -- <3>
  for _, item in ipairs(div.content) do -- <4>
    table.insert(result, item)
  end
  table.insert(result, pandoc.RawBlock('typst', closing)) -- <5>

  return result
end
```

1. Returns two values: opening bracket with function call, closing bracket.
2. Mutates `attrs` table, adding extracted title and removing header from `div.content`.
3. Opening wrapper becomes first element in result list.
4. Original content passes through; Pandoc continues processing nested markdown.
5. Closing bracket completes the Typst function call.

### Title Extraction: A Useful Pattern

Many block components benefit from extracting the first heading as a title.
Instead of requiring users to write:

```markdown
::: {.panel title="My Title"}
Content here.
:::
```

You can let them write:

```markdown
::: {.panel}

# My Title

Content here.
:::
```

The `extract_first_heading_as_title` function handles this:

```{.lua filename="wrapper.lua"}
local function extract_first_heading_as_title(el, attrs)
  if not attrs['title'] and #el.content > 0 then -- <1>
    local first_elem = el.content[1]
    if first_elem.t == 'Header' then -- <2>
      -- Extract header text as title attribute
      attrs['title'] = pandoc.utils.stringify(first_elem.content) -- <3>
      -- Remove header from content
      local new_content = {}
      for i = 2, #el.content do -- <4>
        table.insert(new_content, el.content[i])
      end
      el.content = new_content
    end
  end
end
```

1. Skip if title already provided via attributes or div is empty.
2. `.t` is the element type; see [Pandoc AST types](https://pandoc.org/lua-filters.html#element-types).
3. Convert header inline content to plain string for the title attribute.
4. Rebuild content list without the first element (the extracted header).

### The Typst Panel Function

On the Typst side, the panel function receives the attributes and content:

```{.typst filename="panels.typ"}
#let render-panel(
  content, // <1>
  title: none,
  style: "subtle",
  icon: none,
  colours: (:), // <2>
  breakable: false,
) = {
  let panel-colours = get-panel-colours(style, colours) // <3>

  // Build optional title display
  let title-display = if has-content(title) { // <4>
    block(
      below: 0.8em,
      text(
        size: 1.1em,
        weight: "semibold",
        fill: panel-colours.title,
        title
      )
    )
  }

  // Render the panel
  block( // <5>
    width: 100%,
    fill: panel-colours.background,
    stroke: 1pt + panel-colours.border,
    radius: 8pt,
    inset: 1.2em,
    breakable: breakable, // <6>
    {
      if title-display != none { title-display }
      text(fill: panel-colours.content, content)
    }
  )
}
```

1. First positional parameter receives the wrapped content from the Lua filter.
2. Empty dictionary `(:)` as default; wrapper function injects actual colours.
3. Returns a [dictionary](https://typst.app/docs/reference/foundations/dictionary/) with background, border, title, and content colours.
4. Conditional returns `none` if title is empty; Typst's `if` is an expression.
5. [`block`](https://typst.app/docs/reference/layout/block/) creates a block-level container with styling.
6. `breakable: false` prevents the panel from splitting across page breaks.

The `breakable: false` default prevents panels from splitting across pages, avoiding awkward orphaned titles or content fragments.

## Conclusion

This tutorial introduced the dual-layer architecture for building Quarto Typst templates.
You have learned how Lua filters and Typst functions work together to transform markdown elements into styled PDF components.

### Key Concepts Recap

The dual-layer architecture separates concerns effectively:

1. **Lua filters** intercept markdown elements and generate Typst function calls using `pandoc.RawBlock` and `pandoc.RawInline`.
2. **Typst functions** receive that generated code and render styled output with access to document context.
3. **Wrapper functions** bridge parse-time (Lua) and render-time (Typst), injecting runtime context like colour schemes.

For inline elements like badges, Lua extracts content and attributes, then generates a Typst function call.
For block elements like panels, Lua wraps the content with opening and closing Typst code, preserving nested structure.

### What Comes Next

[Part 2](/posts/2026-03-02-typst-template-tutorial-part2/) builds on these foundations with advanced patterns:

- Handler factories for reducing repetitive code.
- Complex components like card grids with nested data extraction.
- Configuration systems for user-extensible mappings.
- Value conversion and type safety between Lua and Typst.
- WCAG accessibility compliance for colour contrast.

### Further Resources

- [Quarto Documentation: Creating Extensions](https://quarto.org/docs/extensions/creating.html).
- [Pandoc Lua Filters](https://pandoc.org/lua-filters.html).
- [Typst Documentation](https://typst.app/docs/).
- [quarto-mcanouil Extension](https://github.com/mcanouil/quarto-mcanouil).
- [R for the Rest of Us: Typst + Quarto](https://rfortherestofus.com/2025/11/quarto-typst-pdf).
