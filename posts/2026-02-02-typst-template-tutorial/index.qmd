---
title: "Building a Quarto Typst Template: Pairing Lua and Typst for Rich PDF Branding"
description: |
  This tutorial explores how to build sophisticated Quarto extensions that pair Lua filters with Typst templates.
  Starting with simple components and progressing to complex layouts, you will learn the patterns that enable rich PDF branding whilst maintaining clean, extensible code.
date: "2026-02-02"
categories:
  - quarto
  - extensions
  - typst
  - lua
  - pdf
image: featured.png
image-alt: "Quarto logo and Typst logo connected by flowing lines representing the Lua bridge between them."
lang: en-GB
number-sections: true
link-external-newwindow: true
lightbox: true
---

![](featured.png){
  .img-featured
  .img-fluid
  fig-align="center"
  fig-alt='{{< meta image-alt >}}'
  width="600px"
}

## Why PDF Branding Matters

In professional environments, document presentation is not merely aesthetic; it is a reflection of organisational identity and credibility.
Whether you are producing academic papers, corporate reports, client proposals, or technical documentation, consistent branding transforms disparate documents into a cohesive portfolio that reinforces trust and recognition.

Yet achieving this consistency manually is fraught with challenges.
Copy-pasting styles between documents introduces errors.
Updating a colour scheme across dozens of files becomes a maintenance nightmare.
And when multiple team members contribute to documents, stylistic drift is inevitable.

:::: {.highlight}

**Reproducible branding** through code eliminates manual styling errors and ensures every document reflects your organisation's identity automatically.

:::

This is where programmatic document styling becomes valuable.
By defining your brand elements in code, you gain:

- **Consistency**: Every document automatically inherits the correct fonts, colours, and layouts.
- **Maintainability**: Update your brand in one place, and changes propagate everywhere.
- **Reproducibility**: Anyone can generate identically styled documents from the same source.
- **Version control**: Track changes to your brand elements alongside your content.

Typst offers a modern, programmable alternative to LaTeX for PDF generation.
Its syntax is cleaner, compilation is faster, and its scripting capabilities make complex layouts achievable without the arcane incantations that LaTeX often requires.
When paired with Quarto's publishing ecosystem, Typst becomes a powerful foundation for branded document production.

## Prior Art: Getting Started with Typst and Quarto

Before diving into advanced techniques, it is worth acknowledging excellent foundational resources recently published.
David Keyes wrote a comprehensive introduction to using Typst with Quarto at [R for the Rest of Us](https://rfortherestofus.com/2025/11/quarto-typst-pdf).
If you are new to Typst or want a gentler introduction, that post provides an excellent starting point.

This tutorial builds upon that foundation.
Where David's post shows how to use Typst templates with Quarto, this tutorial explores how to *build* sophisticated templates that pair Lua filters with Typst rendering functions.
What does this mean in practice?
It means creating reusable components like badges, panels, and card grids that authors can invoke with simple markdown syntax instead of writing Typst code directly.

In this tutorial, you will learn the architectural patterns that enable rich, interactive components whilst maintaining clean, extensible code.

:::: {.callout-note}

This tutorial uses examples from the ['mcanouil' Quarto extension](https://github.com/mcanouil/quarto-mcanouil).
Whilst the patterns are broadly applicable, some implementation details are specific to that extension's architecture and opinionated design choices.

:::

## The Problem: Bridging Markdown and Typst

Consider a simple scenario: you want users to write badges in their Quarto documents using familiar markdown syntax, but have them render as styled components in Typst.

```markdown
The task is [Completed]{.badge colour="success"} and ready for review.
```

This should produce a styled badge in the PDF output.
But here is the challenge: Typst templates alone cannot intercept and transform markdown elements.
Typst receives content *after* Quarto and Pandoc have processed it, so by the time your template sees the document, that `.badge` span has already been converted to plain text.

The solution requires two layers working in concert:

1. **Lua filters** that intercept markdown elements during Pandoc processing and generate Typst code.
2. **Typst functions** that receive that generated code and render styled output.

The transformation looks like this:

```{mermaid}
%%| label: fig-bridge
%%| fig-cap: "The bridge between markdown and Typst."
%%| fig-alt: "Diagram showing the transformation of markdown syntax `[Completed]{.badge colour='success'}` through Pandoc AST processing by Lua filter into Typst code `#mcanouil-badge(colour: 'success')[Completed]` which is then rendered by Typst function into a styled badge component."
flowchart LR
    A["[Completed]{.badge colour='success'}"] --> B[Pandoc AST]
    B --> C[Lua Filter]
    C --> D["#mcanouil-badge(colour: 'success')[Completed]"]
    D --> E[Typst Function]
    E --> F[Styled Badge]
```

## The Dual-Layer Architecture

This tutorial explores a dual-layer architecture where Lua handles document transformation and Typst handles rendering.

### Layer 1: Document Processing (Lua)

Lua filters operate on Pandoc's Abstract Syntax Tree (AST), the intermediate representation of your document after Quarto parses the markdown.
At this stage, you can:

- Identify elements by their classes (*e.g.*, `.badge`, `.panel`).
- Extract attributes (*e.g.*, `colour="success"`).
- Generate raw Typst code to replace those elements.

The key Pandoc functions for this bridge are:

```{.lua filename="Lua"}
-- For block-level elements (divs, paragraphs)
pandoc.RawBlock('typst', '#my-function[content]') -- <1>

-- For inline elements (spans, text)
pandoc.RawInline('typst', '#my-function[content]') -- <2>
```

1. Creates a block-level raw element; see [Pandoc Lua types](https://pandoc.org/lua-filters.html#type-rawblock).
2. Creates an inline raw element; see [Pandoc Lua types](https://pandoc.org/lua-filters.html#type-rawinline).

These functions tell Pandoc to pass the string directly to Typst without further processing.

### Layer 2: Template Rendering (Typst)

On the Typst side, you define functions that receive the generated code and produce styled output.
These functions have access to:

- The document's colour scheme and typography settings.
- Page dimensions and layout context.
- Typst's full styling capabilities.

A simple Typst function might look like:

```{.typst filename="Typst"}
#let my-badge(content, colour: "neutral") = { // <1>
  box( // <2>
    fill: luma(230), // <3>
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, content)
  )
}
```

1. Function definition with content parameter and optional named parameter.
2. [`box`](https://typst.app/docs/reference/layout/box/) creates an inline container.
3. [`luma`](https://typst.app/docs/reference/visualize/color/#definitions-luma) creates a greyscale colour (0-255).

### Why This Separation?

This dual-layer approach offers several advantages:

- **Separation of concerns**: Lua handles "what to transform", Typst handles "how to render".
- **Flexibility**: Change the rendering without touching the transformation logic, or vice versa.
- **Testability**: Each layer can be developed and tested independently.
- **Reusability**: Typst functions can be called directly in Typst code, not just through the Lua bridge.

## Extension Structure Overview

Before diving into component implementation, let us establish the file organisation pattern used throughout this tutorial.

```txt
_extensions/my-extension/
├── _extension.yml           # Extension manifest
├── typst/
│   ├── template.typ         # Main Typst template entry point
│   ├── filters/
│   │   └── my-filter.lua    # Lua filter for element transformation
│   ├── shortcodes/
│   │   └── my-shortcode.lua # Optional shortcode implementations
│   ├── _modules/            # Shared Lua utilities
│   │   ├── utils.lua
│   │   ├── config.lua
│   │   ├── wrapper.lua
│   │   ├── typst-utils.lua
│   │   └── content-extraction.lua
│   └── partials/
│       ├── typst-show.typ   # Wrapper functions
│       └── libs/
│           ├── badges.typ   # Component rendering functions
│           └── panels.typ
```

:::: {.highlight}

The `_modules/` directory contains shared Lua utilities, whilst `partials/libs/` contains Typst component libraries.
This separation keeps transformation logic separate from rendering logic.

:::

The `_extension.yml` manifest declares how these pieces fit together:

```{.yaml filename="_extension.yml"}
title: My Extension
version: 1.0.0
contributes:
  formats:
    typst:
      template: typst/template.typ
      template-partials:
        - typst/partials/typst-show.typ
        - typst/partials/libs/badges.typ
      filters:
        - typst/filters/my-filter.lua
```

With this foundation established, we can now explore how to build components of increasing complexity, starting with simple inline badges and progressing to complex grid layouts.

## First Component: Badges (Inline Elements)

Badges are compact inline indicators, perfect for showing status, categories, or tags.
They represent the simplest component type: a span element with optional attributes that transforms into a styled box.

### Understanding Pandoc Span Elements

When you write `[Completed]{.badge colour="success"}` in your Quarto document, Pandoc parses this into a Span element in its AST.
The Span contains:

- **`span.content`**: The text content ("Completed").
- **`span.classes`**: A list of classes (["badge"]).
- **`span.attributes`**: A table of key-value pairs ({colour = "success"}).

A Lua filter can inspect these properties and decide how to transform the element.

### Building the Typst Function: Start Simple

Let us begin with the simplest possible badge function in Typst:

```{.typst filename="badges.typ (v1 - minimal)"}
#let simple-badge(content) = {
  box(
    fill: luma(230),
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, content)
  )
}
```

This creates a grey box with rounded corners around any content.
It works, but it lacks colour customisation and accessibility considerations.

### Adding Colour Support

Next, let us add colour support with predefined semantic colours:

```{.typst filename="badges.typ (v2 - with colours)"}
#let get-badge-colour(colour-name) = {
  if colour-name == "success" { rgb("#009955") }
  else if colour-name == "warning" { rgb("#cc6600") }
  else if colour-name == "danger" { rgb("#cc0000") }
  else if colour-name == "info" { rgb("#0066cc") }
  else { luma(128) }  // neutral default
}

#let simple-badge(content, colour: "neutral") = {
  let base = get-badge-colour(colour)
  box(
    fill: base.lighten(80%),
    stroke: 0.5pt + base.lighten(40%),
    radius: 4pt,
    inset: 0.25em,
    text(size: 0.85em, fill: base, content)
  )
}
```

Now users can specify `colour: "success"` and get a green badge.

### The Full Implementation: WCAG Compliance

The complete implementation in the quarto-mcanouil extension adds:

- **Dark mode support**: Colours adapt based on the document's brand mode.
- **WCAG AA compliance**: Text colours are validated against backgrounds for 4.5:1 contrast ratio.
- **Icon support**: Optional icons before the badge text.

Here is a simplified version showing the key patterns:

```{.typst filename="badges.typ (v3 - production)"}
/// Get badge colours with dark mode support
#let get-badge-colours(colour, colours) = {
  // Detect dark mode from the colour scheme
  let fg-components = colours.foreground.components()
  let is-dark-mode = fg-components.at(0, default: 0%) > 50%

  let base = if colour == "success" { callout-colour("tip") }
    else if colour == "warning" { callout-colour("warning") }
    else if colour == "danger" { callout-colour("important") }
    else if colour == "info" { callout-colour("note") }
    else { colours.muted }

  // Adjust background based on mode
  let background = if is-dark-mode { base.darken(60%) }
    else { base.lighten(80%) }

  // Ensure text meets WCAG AA (4.5:1 for small text)
  let text-colour = ensure-contrast(base, background, min-ratio: 4.5)

  (background: background, border: base, text: text-colour)
}

/// Render a badge with full styling
#let render-badge(content, colour: "neutral", colours: (:)) = {
  let badge-colours = get-badge-colours(colour, colours)
  box(
    fill: badge-colours.background,
    stroke: 0.5pt + badge-colours.border,
    radius: 4pt,
    inset: 0.25em,
    height: 1em,
    baseline: 0.25em,
    text(size: 0.85em, weight: "medium", fill: badge-colours.text, content)
  )
}
```

:::: {.highlight}

**WCAG AA compliance** requires 4.5:1 contrast ratio for small text (below 14pt bold or 18pt regular).
Badge text at 0.85em typically falls into this category.

:::

### Building the Lua Handler

With the Typst function ready, we need a Lua handler to generate calls to it.
Here is the simplest approach:

```{.lua filename="badges.lua (v1 - minimal)"}
function Span(span) -- <1>
  -- Only process spans with the 'badge' class
  if not span.classes:includes('badge') then -- <2>
    return span
  end

  -- Extract content as plain text
  local content = pandoc.utils.stringify(span.content) -- <3>

  -- Get the colour attribute (default to neutral)
  local colour = span.attributes.colour or 'neutral' -- <4>

  -- Generate Typst function call
  local typst_code = string.format( -- <5>
    '#simple-badge(colour: "%s")[%s]',
    colour,
    content
  )

  return pandoc.RawInline('typst', typst_code) -- <6>
end
```

1. [Span filter function](https://pandoc.org/lua-filters.html#type-span) receives each span element.
2. Check if span has the target class; return unchanged if not.
3. [`stringify`](https://pandoc.org/lua-filters.html#pandoc.utils.stringify) converts AST content to plain text.
4. Access attributes as a Lua table; provide default value.
5. Build the Typst function call string with parameters.
6. Return raw Typst code that Pandoc passes through unchanged.

This works for our simple use case.
The Lua filter checks if a span has the `badge` class, extracts its content and attributes, and generates a Typst function call.

### Using the Wrapper Module

As your extension grows, you will want to abstract common patterns.
The quarto-mcanouil extension uses a [wrapper module](https://github.com/mcanouil/quarto-mcanouil/blob/main/_extensions/mcanouil/typst/_modules/wrapper.lua) to handle attribute conversion and function call generation:

```{.lua filename="badges.lua (production)"}
local wrapper = require( -- <1>
  quarto.utils.resolve_path('../_modules/wrapper.lua'):gsub('%.lua$', '')
)

local function process_span(span, config) -- <2>
  -- Convert content to plain text
  local content = pandoc.utils.stringify(span.content)

  -- Convert attributes to table
  local attrs = wrapper.attributes_to_table(span) -- <3>

  -- Determine if we should pass attributes
  local has_attributes = next(attrs) ~= nil -- <4>
  local should_pass = config.arguments or has_attributes

  -- Build function call using wrapper utilities
  local typst_code = wrapper.build_function_call( -- <5>
    config.wrapper,  -- e.g., 'mcanouil-badge'
    content,
    attrs,
    should_pass
  )

  return pandoc.RawInline('typst', typst_code)
end
```

1. Load shared wrapper module using [Quarto's path resolution](https://quarto.org/docs/extensions/lua-api.html#quarto.utils.resolve_path).
2. Handler receives `config` from the configuration system (see @sec-config).
3. Convert Pandoc attributes to a Lua table for easier manipulation.
4. [`next()`](https://www.lua.org/manual/5.4/manual.html#pdf-next) returns nil for empty tables; tests if attributes exist.
5. Utility function handles type conversion and string building.

The `config` parameter comes from the configuration system (covered in @sec-config), allowing users to customise which Typst function handles badge elements.

### The Wrapper Function: Injecting Runtime Colours

There is one more piece to the puzzle.
The Typst rendering function needs access to the document's colour scheme, but Lua generates code at parse time before colours are resolved.
The solution is a **wrapper function** in `typst-show.typ`:

```{.typst filename="typst-show.typ"}
// Define brand mode with default fallback
#let effective-brand-mode = "$if(brand-mode)$$brand-mode$$else$light$endif$" // <1>

// Wrapper for .badge spans - injects colours from template brand-mode
#let mcanouil-badge(content, ..args) = { // <2>
  render-badge(
    content,
    colours: mcanouil-colours(mode: effective-brand-mode), // <3>
    ..args // <4>
  )
}
```

1. Quarto template syntax (`$if()$`) resolves at render time; see [Typst partials](https://quarto.org/docs/journals/templates.html#typst-partials).
2. [Variadic arguments](https://typst.app/docs/reference/foundations/arguments/) (`..args`) capture all additional named parameters.
3. Inject the colour scheme based on current brand mode (light/dark).
4. Spread captured arguments to the rendering function.

The Lua filter generates `#mcanouil-badge(colour: "success")[Completed]`.
At render time, `mcanouil-badge` calls `render-badge` with the appropriate colour scheme based on the document's brand mode.

:::: {.highlight}

**Wrapper functions** bridge the gap between parse-time code generation (Lua) and render-time colour resolution (Typst).
They inject runtime context that Lua cannot know in advance.

:::

## Block Components: Panels (Wrapped Content)

Badges are inline elements with simple text content.
Panels are block elements that can contain rich, nested content: paragraphs, lists, images, even code blocks.
This introduces a new challenge: how do we preserve and pass through complex content whilst still wrapping it in our Typst function?

### Understanding Pandoc Div Elements

When you write a fenced div in Quarto:

```markdown
::: {.panel style="info" title="Important Note"}
This panel contains **rich content** including:

- Bullet points.
- *Formatted text*.
- And more.
:::
```

Pandoc parses this into a Div element with:

- **`div.content`**: An array of block elements (paragraphs, lists, etc.).
- **`div.classes`**: A list of classes (["panel"]).
- **`div.attributes`**: A table of key-value pairs.

The critical difference from spans: `div.content` is not simple text but a list of Pandoc AST nodes that need further processing.

### The Wrapped Content Pattern

Unlike badges where we convert content to plain text, panels need to preserve their content structure.
The solution is to wrap the content with opening and closing Typst code:

```{.lua filename="Conceptual pattern"}
-- Instead of: #panel[plain text]
-- We generate:
-- #panel(style: "info")[
--   <original content passes through>
-- ]

local result = {
  pandoc.RawBlock('typst', '#my-panel(style: "info")['),  -- Opening
  -- Original div.content elements go here
  pandoc.RawBlock('typst', ']')  -- Closing
}
```

This approach lets Pandoc continue processing the inner content (converting markdown to Typst), whilst our wrapper provides the styling context.

### Building the Wrapped Content Handler

The wrapper module provides utilities for this pattern:

```{.lua filename="wrapper.lua"}
--- Build Typst block wrappers with optional attributes
local function build_typst_block_wrappers(config, attrs)
  local has_attributes = next(attrs) ~= nil
  local should_pass = config.arguments or has_attributes

  if should_pass and has_attributes then
    local attr_string = build_attribute_string(attrs)
    return string.format('#%s(%s)[', config.wrapper, attr_string), ']' -- <1>
  else
    return string.format('#%s[', config.wrapper), ']'
  end
end

--- Build wrapped content for components
local function build_wrapped_content(div, config, extract_title)
  local attrs = attributes_to_table(div)

  -- Optionally extract first heading as title attribute
  if extract_title then
    extract_first_heading_as_title(div, attrs) -- <2>
  end

  local opening, closing = build_typst_block_wrappers(config, attrs)

  -- Build result: opening wrapper, content, closing wrapper
  local result = { pandoc.RawBlock('typst', opening) } -- <3>
  for _, item in ipairs(div.content) do -- <4>
    table.insert(result, item)
  end
  table.insert(result, pandoc.RawBlock('typst', closing)) -- <5>

  return result
end
```

1. Returns two values: opening bracket with function call, closing bracket.
2. Mutates `attrs` table, adding extracted title and removing header from `div.content`.
3. Opening wrapper becomes first element in result list.
4. Original content passes through; Pandoc continues processing nested markdown.
5. Closing bracket completes the Typst function call.

### Title Extraction: A Useful Pattern

Many block components benefit from extracting the first heading as a title.
Instead of requiring users to write:

```markdown
::: {.panel title="My Title"}
Content here.
:::
```

You can let them write:

```markdown
::: {.panel}
# My Title

Content here.
:::
```

The `extract_first_heading_as_title` function handles this:

```{.lua filename="wrapper.lua"}
local function extract_first_heading_as_title(el, attrs)
  if not attrs['title'] and #el.content > 0 then -- <1>
    local first_elem = el.content[1]
    if first_elem.t == 'Header' then -- <2>
      -- Extract header text as title attribute
      attrs['title'] = pandoc.utils.stringify(first_elem.content) -- <3>
      -- Remove header from content
      local new_content = {}
      for i = 2, #el.content do -- <4>
        table.insert(new_content, el.content[i])
      end
      el.content = new_content
    end
  end
end
```

1. Skip if title already provided via attributes or div is empty.
2. `.t` is the element type; see [Pandoc AST types](https://pandoc.org/lua-filters.html#element-types).
3. Convert header inline content to plain string for the title attribute.
4. Rebuild content list without the first element (the extracted header).

### Handler Factories: Reducing Repetition

As you build more components, you will notice patterns repeating.
The wrapper module provides factory functions to create handlers:

```{.lua filename="wrapper.lua"}
--- Create handler for wrapped content components
local function create_wrapped_handler(extract_title) -- <1>
  return function(div, config) -- <2>
    return build_wrapped_content(div, config, extract_title)
  end
end

--- Create handler for atomic components (no content wrapping)
local function create_atomic_handler() -- <3>
  return function(div, config)
    local attrs = attributes_to_table(div)
    return build_atomic_function_call(config, attrs) -- <4>
  end
end
```

1. Factory function; `extract_title` is captured in the returned [closure](https://www.lua.org/pil/6.1.html).
2. Returned handler matches the signature expected by the filter dispatcher.
3. Atomic handlers ignore div content; useful for decorative elements like dividers.
4. Generates `#function-name(attrs)[]` without wrapping content.

These factories let you declare handlers concisely:

```{.lua filename="typst-markdown.lua"}
local DIV_HANDLERS = {
  ['panel'] = wrapper.create_wrapped_handler(true),            -- Extract title
  ['divider'] = wrapper.create_wrapped_handler(false),         -- No title
  ['executive-summary'] = wrapper.create_wrapped_handler(true), -- Extract title
  ['value-box'] = wrapper.create_atomic_handler(),              -- No content
  ['progress'] = wrapper.create_atomic_handler(),               -- No content
  ['horizontal-timeline'] = timeline.process_div,               -- Custom handler
}
```

:::: {.highlight}

**Handler factories** encapsulate common patterns.
Use `create_wrapped_handler(true)` for components with titles, `create_wrapped_handler(false)` for content-only wrappers, and `create_atomic_handler()` for components without content.

:::

### The Typst Panel Function

On the Typst side, the panel function receives the attributes and content:

```{.typst filename="panels.typ"}
#let render-panel(
  content, // <1>
  title: none,
  style: "subtle",
  icon: none,
  colours: (:), // <2>
  breakable: false,
) = {
  let panel-colours = get-panel-colours(style, colours) // <3>

  // Build optional title display
  let title-display = if has-content(title) { // <4>
    block(
      below: 0.8em,
      text(
        size: 1.1em,
        weight: "semibold",
        fill: panel-colours.title,
        title
      )
    )
  }

  // Render the panel
  block( // <5>
    width: 100%,
    fill: panel-colours.background,
    stroke: 1pt + panel-colours.border,
    radius: 8pt,
    inset: 1.2em,
    breakable: breakable, // <6>
    {
      if title-display != none { title-display }
      text(fill: panel-colours.content, content)
    }
  )
}
```

1. First positional parameter receives the wrapped content from the Lua filter.
2. Empty dictionary `(:)` as default; wrapper function injects actual colours.
3. Returns a [dictionary](https://typst.app/docs/reference/foundations/dictionary/) with background, border, title, and content colours.
4. Conditional returns `none` if title is empty; Typst's `if` is an expression.
5. [`block`](https://typst.app/docs/reference/layout/block/) creates a block-level container with styling.
6. `breakable: false` prevents the panel from splitting across page breaks.

The `breakable: false` default prevents panels from splitting across pages, avoiding awkward orphaned titles or content fragments.

### Style Variants

The panel implementation supports multiple style variants:

- **subtle**: Muted background, minimal visual impact.
- **emphasis**: Blue-tinted background for drawing attention.
- **accent**: Inverted colours (dark background, light text).
- **outline**: Transparent background with visible border.
- **info**, **success**, **warning**, **danger**: Semantic colours matching callout types.

Each style calculates appropriate colours whilst maintaining WCAG compliance:

```{.typst filename="panels.typ (colour selection)"}
#let get-panel-colours(style, colours) = {
  if style == "info" {
    let info-colour = callout-colour("note") // <1>
    let bg = get-adaptive-background(info-colour, colours) // <2>
    let text-colour = get-wcag-compliant-text-colour(bg, colours, min-ratio: 4.5) // <3>
    (background: bg, border: info-colour, title: text-colour, content: text-colour) // <4>
  } else if style == "success" {
    // Similar pattern for other styles...
  }
}
```

1. `callout-colour` maps semantic names to Quarto's callout colour scheme.
2. Adjusts base colour for light/dark mode (lighten in light mode, darken in dark).
3. Ensures text meets [WCAG AA](https://www.w3.org/WAI/WCAG21/Understanding/contrast-minimum.html) 4.5:1 contrast ratio.
4. Returns a dictionary; Typst uses parentheses for dictionary literals.

## Complex Components: Card Grids

Sometimes the factory patterns are not enough.
Card grids demonstrate a complex component that requires custom data extraction from nested structures.

### When Factories Fall Short

Consider this card grid markup:

```markdown
::: {.card-grid columns="3"}
::: {.card style="info"}
# Card Title

Card content goes here.

---

Footer text
:::

::: {.card style="success"}
# Another Card

More content.
:::
:::
```

This requires:

1. Finding nested `.card` divs within the `.card-grid` div.
2. Extracting the title from each card's first heading.
3. Splitting content from footer (separated by horizontal rule).
4. Building a Typst array data structure to pass all cards to the rendering function.

No simple wrapper pattern handles this complexity.
We need a custom handler.

### Extracting Structured Data

The card extraction function uses the [`content-extraction` module](https://github.com/mcanouil/quarto-mcanouil/blob/main/_extensions/mcanouil/typst/_modules/content-extraction.lua) to parse nested content.
This module provides `parse_sections()`, which handles the common pattern of extracting header, body, and footer sections separated by horizontal rules.

```{.lua filename="card-grid.lua"}
local content_extraction = require( -- <1>
  quarto.utils.resolve_path('../_modules/content-extraction.lua'):gsub('%.lua$', '')
)
local utils = require(
  quarto.utils.resolve_path('../_modules/utils.lua'):gsub('%.lua$', '')
)

--- Extract card data from a div.
local function extract_card(div)
  local parsed = content_extraction.parse_sections(div.content) -- <2>

  return {
    title = parsed.header_text, -- <3>
    content = parsed.body_blocks and #parsed.body_blocks > 0
      and utils.stringify(parsed.body_blocks) or nil, -- <4>
    footer = parsed.footer_blocks and #parsed.footer_blocks > 0
      and utils.stringify(parsed.footer_blocks) or nil,
    style = div.attributes.style,
    colour = div.attributes.colour
  }
end
```

1. Load the content extraction module for reusable parsing utilities.
2. `parse_sections()` parses content into header, body, and footer sections.
3. `header_text` contains the first heading's text; `header_level` contains its level.
4. `body_blocks` contains content before `---`; `footer_blocks` contains content after.

The `parse_sections()` function returns a table with:

- **`header_text`**: Text from the first heading (or nil if none).
- **`header_level`**: Level of the first heading (defaults to 2).
- **`body_blocks`**: Array of blocks before the horizontal rule.
- **`footer_blocks`**: Array of blocks after the horizontal rule.

### Building Typst Data Structures

Once cards are extracted, we need to build a Typst array:

```{.lua filename="card-grid.lua"}
local function process_div(div, config)
  local cards = pandoc.List()
  local columns = div.attributes.columns
    and tonumber(div.attributes.columns) or 3 -- <1>

  -- Extract cards from child divs
  for _, block in ipairs(div.content) do
    if block.t == 'Div' and block.classes:includes('card') then -- <2>
      local card = extract_card(block)
      if card.title or card.content or card.footer then
        cards:insert(card)
      end
    end
  end

  if #cards == 0 then
    return pandoc.Null() -- <3>
  end

  -- Build cards array for Typst
  local card_items = {}
  for _, card in ipairs(cards) do
    local card_parts = {}

    if card.title then
      table.insert(card_parts,
        string.format('title: %s', typst_utils.typst_value(card.title))) -- <4>
    end
    if card.content then
      table.insert(card_parts,
        string.format('content: %s', typst_utils.typst_value(card.content)))
    end
    if card.footer then
      table.insert(card_parts,
        string.format('footer: %s', typst_utils.typst_value(card.footer)))
    end
    if card.style then
      table.insert(card_parts,
        string.format('style: %s', typst_utils.typst_value(card.style)))
    end
    if card.colour then -- <5>
      if card.colour:match('^#') then
        table.insert(card_parts,
          string.format('colour: rgb(%s)', typst_utils.typst_value(card.colour)))
      else
        table.insert(card_parts,
          string.format('colour: %s', typst_utils.typst_value(card.colour)))
      end
    end

    table.insert(card_items, '(' .. table.concat(card_parts, ', ') .. ')') -- <6>
  end

  -- Build final Typst function call
  local typst_code = string.format( -- <7>
    '#mcanouil-card-grid(\n  (%s),\n  columns: %d\n)',
    table.concat(card_items, ',\n    '),
    columns
  )

  return pandoc.RawBlock('typst', typst_code)
end
```

1. [`tonumber()`](https://www.lua.org/manual/5.4/manual.html#pdf-tonumber) converts string attribute to number; defaults to 3.
2. [`:includes()`](https://pandoc.org/lua-filters.html#type-list) checks if class list contains the target class.
3. [`pandoc.Null()`](https://pandoc.org/lua-filters.html#type-null) removes the element from output if no cards found.
4. `typst_value()` handles proper quoting and escaping (see @sec-value-conversion).
5. Hex colours need `rgb()` wrapper in Typst; other values use `typst_value()` directly.
6. Each card becomes a Typst dictionary literal: `(title: "...", content: "...")`.
7. Final output is a Typst array of dictionaries passed to the grid function.

The generated Typst code looks like:

```typst
#mcanouil-card-grid(
  ((title: "Card Title", content: "Card content", footer: "Footer text", style: "info"),
   (title: "Another Card", content: "More content", style: "success")),
  columns: 3
)
```

:::: {.highlight}

**Complex components** require custom handlers that extract structured data from nested elements and build Typst data structures (arrays, dictionaries) that the rendering function can consume.

:::

### The Typst Grid Renderer

On the Typst side, the card grid renderer uses Typst's `grid` function:

```{.typst filename="card-grid.typ"}
#let render-card-grid(cards, colours, columns: 3, gutter: 1em) = {
  // Build grid cells from card data
  let cells = cards.map(card => { // <1>
    let card-colours = get-card-colours(card.at("style", default: "subtle"), colours) // <2>

    block(
      width: 100%,
      fill: card-colours.background,
      stroke: 1pt + card-colours.border,
      radius: 8pt,
      inset: 1em,
      {
        // Title
        if "title" in card { // <3>
          text(weight: "bold", card.title)
          v(0.5em)
        }
        // Content
        if "content" in card {
          card.content
        }
        // Footer
        if "footer" in card {
          v(0.5em)
          line(length: 100%, stroke: 0.5pt + card-colours.border)
          v(0.3em)
          text(size: 0.9em, fill: colours.muted, card.footer)
        }
      }
    )
  })

  // Render as grid
  grid( // <4>
    columns: (1fr,) * columns, // <5>
    gutter: gutter,
    ..cells.flatten() // <6>
  )
}
```

1. [`.map()`](https://typst.app/docs/reference/foundations/array/#definitions-map) transforms each card dictionary into rendered content.
2. [`.at()`](https://typst.app/docs/reference/foundations/dictionary/#definitions-at) safely accesses dictionary keys with a default value.
3. `in` operator checks if key exists in dictionary.
4. [`grid`](https://typst.app/docs/reference/layout/grid/) creates a multi-column layout.
5. `(1fr,) * columns` creates an array of equal fractional widths, *e.g.*, `(1fr, 1fr, 1fr)` for 3 columns.
6. [Spread operator](https://typst.app/docs/reference/foundations/arguments/#spreading) `..` expands array into positional arguments.

The `(1fr,) * columns` pattern creates equal-width columns, and `..cells.flatten()` spreads the cell array into grid arguments.

### Supporting Multiple Input Formats

The timeline component in quarto-mcanouil demonstrates another pattern: accepting multiple input formats.
Events can be specified either as nested divs with attributes or as headings with a specific format:

```markdown
::: {.timeline}
::: {.event date="2024" title="First Event"}
Description of the first event.
:::

## 2025: Second Event

Description using heading format.
:::
```

The handler parses both formats:

```{.lua filename="timeline.lua (conceptual)"}
for _, block in ipairs(div.content) do
  if block.t == 'Div' and block.classes:includes('event') then -- <1>
    -- Event as nested div with attributes
    events:insert({
      date = block.attributes.date,
      title = block.attributes.title,
      description = extract_content(block)
    })
  elseif block.t == 'Header' then -- <2>
    -- Event as heading with "YYYY: Title" format
    local heading_text = pandoc.utils.stringify(block.content)
    local date, title = heading_text:match('^([^:]+):%s*(.+)$') -- <3>
    if date and title then
      events:insert({ date = date, title = title })
    end
  end
end
```

1. Explicit format: attributes on nested `.event` divs.
2. Conventional format: parse structured headings.
3. [Lua pattern](https://www.lua.org/manual/5.4/manual.html#6.4.1) captures text before and after the colon separator.

This flexibility makes components more user-friendly by supporting both explicit attributes and conventional patterns.

## The Configuration System {#sec-config}

A key design goal for reusable extensions is extensibility.
Users should be able to add their own components or override built-in ones without modifying the extension's source code.
The [configuration system](https://github.com/mcanouil/quarto-mcanouil/blob/main/_extensions/mcanouil/typst/_modules/config.lua) enables this through metadata-driven element mappings.

### Built-in Mappings

The extension defines default mappings for all its components:

```{.lua filename="config.lua"}
local function get_builtin_mappings()
  return {
    div = { -- <1>
      ['highlight'] = { wrapper = 'mcanouil-highlight', arguments = false }, -- <2>
      ['value-box'] = { wrapper = 'mcanouil-value-box', arguments = true }, -- <3>
      ['panel'] = { wrapper = 'mcanouil-panel', arguments = true },
      ['divider'] = { wrapper = 'mcanouil-divider', arguments = true },
      ['progress'] = { wrapper = 'mcanouil-progress', arguments = true },
      ['executive-summary'] = { wrapper = 'mcanouil-executive-summary', arguments = true },
      ['card-grid'] = { wrapper = 'mcanouil-card-grid', arguments = true },
      ['timeline'] = { wrapper = 'mcanouil-timeline', arguments = true },
      ['horizontal-timeline'] = { wrapper = 'mcanouil-horizontal-timeline', arguments = true },
    },
    span = {
      ['badge'] = { wrapper = 'mcanouil-badge', arguments = true }
    },
    table = {}, -- <4>
    image = {}
  }
end
```

1. Mappings organised by element type: div, span, table, image.
2. `arguments = false` means attributes only passed when present.
3. `arguments = true` means always generate parameter list (even if empty).
4. Empty tables for future extensibility; table and image handlers not yet implemented.

Each mapping specifies:

- **`wrapper`**: The Typst function name to call.
- **`arguments`**: Whether to always pass attributes (even if empty).

### User Configuration via Metadata

Users can extend or override mappings through document metadata:

```{.yaml filename="document.qmd"}
---
title: "My Document"
extensions:
  typst-markdown:
    divs:
      my-callout: my-custom-callout
      my-box:
        function: my-custom-box
        arguments: true
    spans:
      my-highlight: my-text-highlight
---
```

Two formats are supported:

- **Simple**: `class-name: typst-function-name`
- **Detailed**: `class-name: {function: typst-function-name, arguments: true}`

### Loading User Configuration

The configuration module parses user settings from metadata:

```{.lua filename="config.lua"}
local function load_element_mappings(meta) -- <1>
  local user_mappings = { div = {}, span = {}, table = {}, image = {} }

  -- Read from extensions.typst-markdown namespace
  local extension_config = meta.extensions and meta.extensions['typst-markdown'] -- <2>
  if not extension_config then
    return user_mappings
  end

  -- Process each element type (divs, spans, tables, images)
  local element_types = { -- <3>
    { config_key = 'divs',   mappings_key = 'div' },
    { config_key = 'spans',  mappings_key = 'span' },
    { config_key = 'tables', mappings_key = 'table' },
    { config_key = 'images', mappings_key = 'image' }
  }

  for _, element_type in ipairs(element_types) do
    if extension_config[element_type.config_key] then
      for class, config in pairs(extension_config[element_type.config_key]) do -- <4>
        local parsed = parse_and_validate_config(config, class)
        if parsed then
          user_mappings[element_type.mappings_key][class] = parsed
        end
      end
    end
  end

  return user_mappings
end
```

1. `meta` is the [document metadata](https://pandoc.org/lua-filters.html#type-meta) from YAML front matter.
2. Short-circuit evaluation: returns nil if `meta.extensions` is nil.
3. Data-driven approach avoids repetitive if/else blocks for each element type.
4. [`pairs()`](https://www.lua.org/manual/5.4/manual.html#pdf-pairs) iterates over all key-value pairs in the table.

### Configuration Parsing and Validation

The parser handles both simple and detailed formats with helpful error messages:

```{.lua filename="config.lua"}
local function parse_and_validate_config(config, class)
  local config_str = utils.stringify(config) -- <1>

  -- Simple string format: 'my-class: my-function'
  if type(config) == 'string' or (config_str and not string.find(config_str, '[%{%[]')) then -- <2>
    if utils.is_empty(config_str) then
      utils.log_warning(EXTENSION_NAME, 'Empty function name for class "' .. class .. '"') -- <3>
      return nil
    end
    return { wrapper = config_str, arguments = false }

  -- Table format: 'my-class: {function: my-func, arguments: true}'
  elseif type(config) == 'table' then
    local func_name = config['function'] -- <4>
    if not func_name then
      utils.log_warning(EXTENSION_NAME,
        'Missing "function" key for class "' .. class .. '". ' ..
        'Use: ' .. class .. ': function-name or ' .. class .. ': {function: function-name}')
      return nil
    end
    return {
      wrapper = utils.stringify(func_name),
      arguments = config['arguments'] == true -- <5>
    }
  else
    utils.log_warning(EXTENSION_NAME,
      'Invalid configuration for class "' .. class .. '". ' ..
      'Expected string or table, got ' .. type(config))
    return nil
  end
end
```

1. Convert Pandoc MetaValue to plain string for comparison.
2. Pattern `[%{%[]` detects curly braces or brackets indicating structured config.
3. Warnings appear in Quarto render output; guide users to correct syntax.
4. Bracket notation required; `function` is a reserved word in Lua.
5. Explicit `== true` check; other truthy values default to false.

### Merging Configurations

User configuration overrides built-in defaults:

```{.lua filename="config.lua"}
local function merge_configurations(builtin, user)
  local merged = {}

  -- Start with built-in configuration
  for class, config in pairs(builtin) do -- <1>
    merged[class] = config
  end

  -- Override with user configuration
  for class, config in pairs(user) do -- <2>
    merged[class] = config
  end

  return merged
end
```

1. Copy all built-in mappings first.
2. User mappings overwrite built-in ones with same key; new keys are added.

### Using Configuration in Filters

The main filter loads configuration during the `Meta` pass:

```{.lua filename="typst-markdown.lua"}
local DIV_MAPPINGS = {} -- <1>
local SPAN_MAPPINGS = {}

function Meta(meta) -- <2>
  local builtin = config_module.get_builtin_mappings()
  local user = config_module.load_element_mappings(meta)

  DIV_MAPPINGS = config_module.merge_configurations(builtin.div, user.div)
  SPAN_MAPPINGS = config_module.merge_configurations(builtin.span, user.span)

  return meta -- <3>
end

function Div(div) -- <4>
  for _, class in ipairs(div.classes) do
    if DIV_MAPPINGS[class] then -- <5>
      local config = DIV_MAPPINGS[class]
      local handler = DIV_HANDLERS[class]
      if handler then
        return handler(div, config) -- <6>
      end
      -- Default handling...
    end
  end
  return div
end
```

1. Module-level variables persist across filter function calls.
2. [`Meta`](https://pandoc.org/lua-filters.html#type-meta) filter runs once before element filters.
3. Must return meta (even unmodified) to continue processing.
4. [`Div`](https://pandoc.org/lua-filters.html#type-div) filter called for each div element in document.
5. Check if any of the div's classes have a registered mapping.
6. Handler receives both the element and its configuration; returns replacement.

:::: {.highlight}

**Configuration-driven design** separates "what to transform" (class mappings) from "how to transform" (handlers), enabling users to add components without modifying extension code.

:::

### Adding Custom Handlers

To add a completely new component type, users need to:

1. Define a Typst function for rendering.
2. Add a mapping in document metadata.
3. If the component requires special processing, the extension would need to be extended with a custom handler.

For simple wrapped or atomic components, the default handling often suffices.
The configuration maps the class to a function, and the factory handlers do the rest.

## Value Conversion and Type Safety

When generating Typst code from Lua, you must convert Lua values to valid Typst syntax.
The [`typst-utils` module](https://github.com/mcanouil/quarto-mcanouil/blob/main/_extensions/mcanouil/typst/_modules/typst-utils.lua) provides utilities for this.
This seemingly simple task has nuances that, if handled incorrectly, lead to subtle bugs.

### The `typst_value` Function

The core conversion function handles different value types:

```{.lua filename="typst-utils.lua"}
M.typst_value = function(value)
  -- Ensure value is a string
  if value == nil then value = '' end
  if type(value) ~= 'string' then value = tostring(value) end -- <1>

  -- Boolean conversion: pass through unquoted
  if value == 'true' then return 'true' end -- <2>
  if value == 'false' then return 'false' end

  -- Number with unit (e.g., 50%, 1.5em, 10pt, 2cm)
  if value:match('^%-?%d+%.?%d*%%$') or value:match('^%-?%d+%.?%d*[a-z]+$') then -- <3>
    return value
  end

  -- Plain number (integer or decimal)
  if value:match('^%-?%d+%.?%d*$') then return value end -- <4>

  -- Typst function call (e.g., rgb(...), color.mix(...))
  if value:match('^[%w%.%-]+%b()$') then -- <5>
    return value
  end

  -- String (default): quote and escape
  return '"' .. M.escape_attribute_value(value) .. '"' -- <6>
end
```

1. Coerce all inputs to strings for consistent pattern matching.
2. Typst booleans are unquoted keywords; return as-is.
3. Pattern matches optional negative sign, digits, optional decimal, then `%` or unit suffix.
4. `^%-?%d+%.?%d*$` matches integers and decimals like `42`, `-3.14`.
5. `%b()` is a [balanced pattern](https://www.lua.org/manual/5.4/manual.html#6.4.1) matching parentheses.
6. Default case: wrap in quotes after escaping special characters.

This function distinguishes between:

- **Booleans**: `true` and `false` are passed through unquoted.
- **Numbers with units**: `50%`, `1.5em`, `10pt` remain unquoted.
- **Plain numbers**: `42`, `3.14` remain unquoted.
- **Function calls**: `rgb("#ff0000")`, `color.mix(...)` are detected and passed through.
- **Strings**: Everything else is quoted and escaped.

### Attribute Escaping

String values need proper escaping to prevent Typst syntax errors:

```{.lua filename="typst-utils.lua"}
M.escape_attribute_value = function(value)
  local result = value:gsub('\\', '\\\\'):gsub('"', '\\"') -- <1>
  return result
end
```

1. [`:gsub()`](https://www.lua.org/manual/5.4/manual.html#pdf-string.gsub) performs global substitution; chained calls process sequentially.

This escapes:

- Backslashes: `\` becomes `\\`.
- Double quotes: `"` becomes `\"`.

Without escaping, a value like `Say "Hello"` would break the Typst string syntax.

### Handling Colours

Colours require special attention.
Users might specify colours as:

- Named colours: `success`, `info`, `warning`.
- Hex codes: `#ff0000`.
- Typst functions: `rgb(255, 0, 0)`.

The card-grid handler demonstrates proper colour handling:

```{.lua filename="card-grid.lua"}
if card.colour then
  -- Hex colours need rgb() wrapper
  if card.colour:match('^#') then -- <1>
    table.insert(card_parts,
      string.format('colour: rgb(%s)', typst_utils.typst_value(card.colour))) -- <2>
  else
    -- Named colours or function calls pass through
    table.insert(card_parts,
      string.format('colour: %s', typst_utils.typst_value(card.colour))) -- <3>
  end
end
```

1. Pattern `^#` matches strings starting with hash (hex colour notation).
2. Wrap hex code in [`rgb()`](https://typst.app/docs/reference/visualize/color/#definitions-rgb); Typst does not parse bare hex codes.
3. Named colours and existing function calls pass through unchanged.

Hex colours like `#ff0000` need wrapping in `rgb()` because Typst does not recognise bare hex codes.

### Building Attribute Strings

The wrapper module builds complete attribute strings for function calls:

```{.lua filename="wrapper.lua"}
local function build_attribute_string(attrs)
  local attr_items = {}
  for key, value in pairs(attrs) do
    table.insert(attr_items,
      string.format('%s: %s', key, typst_utils.typst_value(value))) -- <1>
  end
  return table.concat(attr_items, ', ') -- <2>
end
```

1. Each attribute becomes `key: typst_value` format for Typst named parameters.
2. [`table.concat`](https://www.lua.org/manual/5.4/manual.html#pdf-table.concat) joins array elements with separator.

This generates output like `style: "info", title: "My Title", breakable: true`.

:::: {.highlight}

**Type-safe value conversion** is critical.
Always use a dedicated conversion function rather than string concatenation to avoid syntax errors and security issues.

:::

## Shortcodes as an Alternative Pattern

So far we have focused on filters that transform markdown elements.
Shortcodes offer an alternative approach with explicit syntax.

### Filters vs Shortcodes

**Filters** transform elements implicitly based on classes:

```markdown
[Completed]{.badge colour="success"}
```

**Shortcodes** use explicit syntax:

```markdown
{{< progress value="75" colour="info" >}}
```

When to use each:

- **Filters**: For semantic markup that should work across formats, or when transforming existing patterns.
- **Shortcodes**: For explicit, format-specific components, or when there is no natural markdown representation.

### The Shortcode Handler Factory

The `typst-utils` module provides a factory for creating shortcode handlers:

```{.lua filename="typst-utils.lua"}
M.create_shortcode_handler = function(function_name, param_mapping) -- <1>
  return function(_args, kwargs, _meta) -- <2>
    -- Only process for Typst format
    if not quarto.doc.is_format('typst') then -- <3>
      return pandoc.Null()
    end

    local typst_code = M.build_shortcode_function_call(function_name, kwargs, param_mapping)
    return pandoc.RawBlock('typst', typst_code)
  end
end
```

1. Factory pattern: returns a configured handler function.
2. Shortcode signature: `_args` (positional), `kwargs` (named), `_meta` (document metadata).
3. [`quarto.doc.is_format()`](https://quarto.org/docs/extensions/lua-api.html#quarto.doc.is_format) checks output format.

The factory:

1. Checks if output format is Typst.
2. Builds the function call with converted parameters.
3. Returns a RawBlock with the generated code.

### Complete Shortcode Example

Here is the progress bar shortcode implementation:

```{.lua filename="shortcodes/progress.lua"}
local typst_utils = require(
  quarto.utils.resolve_path('../_modules/typst-utils.lua'):gsub('%.lua$', '')
)

return { -- <1>
  ['progress'] = typst_utils.create_shortcode_handler('mcanouil-progress') -- <2>
}
```

1. Shortcode files return a table mapping shortcode names to handlers.
2. The shortcode `{{</* progress */>}}` calls `mcanouil-progress` in Typst.

Usage in documents:

```markdown
{{< progress value="75" colour="success" label="Completion" >}}
```

Generated Typst:

```typst
#mcanouil-progress(value: 75, colour: "success", label: "Completion")[]
```

### Parameter Mapping

The factory supports parameter name mapping for compatibility:

```{.lua filename="Example with mapping"}
return {
  ['my-shortcode'] = typst_utils.create_shortcode_handler(
    'my-typst-function',
    { color = 'colour' }  -- <1>
  )
}
```

1. Mapping table: keys are input parameter names, values are output names.

This allows users to write `color="red"` whilst the Typst function receives `colour: "red"`.

## Advanced Topics

### Format Checking

Always check the output format before generating format-specific code:

```{.lua filename="Format checking pattern"}
function Div(div)
  if not quarto.doc.is_format('typst') then -- <1>
    return div  -- Return unchanged for other formats
  end
  -- Process for Typst...
end
```

1. Early return pattern: check format first, process only if matched.

This ensures your filter does not break HTML or PDF output via LaTeX.

### Module Loading Pattern

Quarto extensions use a specific pattern for loading modules:

```{.lua filename="Module loading"}
local config_module = require(
  quarto.utils.resolve_path('../_modules/config.lua'):gsub('%.lua$', '') -- <1>
)
```

1. `resolve_path` returns absolute path; `:gsub('%.lua$', '')` strips extension for [`require`](https://www.lua.org/manual/5.4/manual.html#pdf-require).

The `quarto.utils.resolve_path()` function resolves paths relative to the current file, and `:gsub('%.lua$', '')` removes the `.lua` extension (required by Lua's `require`).

### Filter Ordering: Two-Pass Processing

Pandoc filters can return multiple filter tables to control processing order:

```{.lua filename="typst-markdown.lua"}
return { -- <1>
  { Meta = Meta },                                    -- <2>
  { Div = Div, Span = Span, Table = Table, Image = Image }  -- <3>
}
```

1. Returning an array of filter tables enables [multi-pass filtering](https://pandoc.org/lua-filters.html#filter-execution-order).
2. First pass: `Meta` runs once to load and merge configuration.
3. Second pass: element filters use the configuration loaded in pass one.

The `Meta` function runs first to load configuration, ensuring mappings are available when element transformations occur.

### Debugging Techniques

When developing filters, these techniques help:

**Logging output**:

```{.lua filename="Debug logging"}
quarto.log.warning('Processing div with classes: ' .. table.concat(div.classes, ', ')) -- <1>
quarto.log.output('Generated Typst code:', typst_code) -- <2>
```

1. [`quarto.log.warning()`](https://quarto.org/docs/extensions/lua-api.html#quarto.log) outputs to stderr; visible by default.
2. `quarto.log.output()` writes to stdout; use with `--trace` flag.

Use `--trace` flag when rendering to see log output.

**Inspecting AST**:

```{.lua filename="AST inspection"}
local content_str = pandoc.utils.stringify(div.content)
quarto.log.output('Content as string:', content_str)
```

**Testing in isolation**:

Create minimal test documents to isolate issues:

```{.markdown filename="test.qmd"}
---
format: typst
---

[Test]{.badge colour="success"}
```

## Putting It All Together: Building a Quote Card

Let us apply everything we have learned by building a new component from scratch: a styled quote card for displaying quotations with attribution.

### Step 1: Design the Markdown Syntax

First, decide how users will write quote cards:

```markdown
::: {.quote-card author="Alan Kay" source="1971"}
The best way to predict the future is to invent it.
:::
```

Alternatively, support heading-based author attribution:

```markdown
::: {.quote-card source="1971"}
The best way to predict the future is to invent it.

## Alan Kay
:::
```

### Step 2: Create the Typst Rendering Function

Create `partials/libs/quote-card.typ`:

```{.typst filename="quote-card.typ"}
// Quote card rendering for styled quotations
// Author: Your Name
// License: MIT

#let QUOTE-CARD-RADIUS = 8pt // <1>
#let QUOTE-CARD-INSET = 1.5em
#let QUOTE-MARK-SIZE = 3em

/// Render a styled quote card
#let render-quote-card(
  content,
  author: none,
  source: none,
  colours: (:),
) = {
  // Get colours for styling
  let bg = colours.at("background", default: luma(250)) // <2>
  let fg = colours.at("foreground", default: luma(50))
  let muted = colours.at("muted", default: luma(128))
  let accent = callout-colour("note")

  block(
    width: 100%,
    fill: bg,
    stroke: (left: 4pt + accent), // <3>
    radius: (right: QUOTE-CARD-RADIUS), // <4>
    inset: QUOTE-CARD-INSET,
    {
      // Opening quote mark
      place( // <5>
        top + left,
        dx: -0.5em,
        dy: -0.3em,
        text(size: QUOTE-MARK-SIZE, fill: accent.lighten(60%), sym.quote.l.double)
      )

      // Quote content
      pad(left: 1em, right: 1em)[
        #text(style: "italic", fill: fg, content)
      ]

      // Attribution line
      if author != none or source != none {
        v(0.8em)
        align(right)[
          #text(fill: muted)[
            #sym.dash.em // <6>
            #if author != none { [ #author] }
            #if source != none { [, #emph(source)] }
          ]
        ]
      }
    }
  )
}
```

1. Constants defined at module level for easy customisation.
2. Safe dictionary access with defaults; works even if colours dictionary is incomplete.
3. [Directional stroke](https://typst.app/docs/reference/visualize/stroke/): only left edge has a border.
4. [Directional radius](https://typst.app/docs/reference/layout/block/#parameters-radius): rounds only right corners.
5. [`place`](https://typst.app/docs/reference/layout/place/) positions content absolutely within the container.
6. [`sym.dash.em`](https://typst.app/docs/reference/symbols/sym/) is the em dash symbol (—).

### Step 3: Create the Wrapper Function

Add to `typst-show.typ`:

```{.typst filename="typst-show.typ (addition)"}
// Wrapper for .quote-card divs
#let mcanouil-quote-card(content, ..args) = { // <1>
  render-quote-card(
    content,
    colours: mcanouil-colours(mode: effective-brand-mode), // <2>
    ..args // <3>
  )
}
```

1. Wrapper function name matches the `wrapper` value in configuration.
2. Injects runtime colour scheme; `effective-brand-mode` resolved from template.
3. Spreads remaining arguments (`author`, `source`) to the renderer.

### Step 4: Create the Lua Handler

For a simple component, use the factory:

```{.lua filename="Using factory handler"}
-- In DIV_HANDLERS:
['quote-card'] = wrapper.create_wrapped_handler(false)
```

For author extraction from headings, create a custom handler in `_modules/quote-card.lua`:

```{.lua filename="quote-card.lua"}
local wrapper = require(
  quarto.utils.resolve_path('../_modules/wrapper.lua'):gsub('%.lua$', '')
)

local function process_div(div, config)
  local attrs = wrapper.attributes_to_table(div)

  -- Extract author from last heading if not in attributes
  if not attrs['author'] and #div.content > 0 then -- <1>
    local last_elem = div.content[#div.content] -- <2>
    if last_elem.t == 'Header' then
      attrs['author'] = pandoc.utils.stringify(last_elem.content)
      -- Remove the heading from content
      local new_content = {}
      for i = 1, #div.content - 1 do
        table.insert(new_content, div.content[i])
      end
      div.content = new_content -- <3>
    end
  end

  -- Build wrapped content
  local opening, closing = wrapper.build_typst_block_wrappers(config, attrs)
  local result = { pandoc.RawBlock('typst', opening) }
  for _, item in ipairs(div.content) do
    table.insert(result, item)
  end
  table.insert(result, pandoc.RawBlock('typst', closing))

  return result
end

return { -- <4>
  process_div = process_div
}
```

1. Only extract from heading if `author` not already provided via attributes.
2. Access last element; quote cards put attribution at the end.
3. Mutate div content to remove the extracted heading.
4. Export the handler for registration in the main filter.

### Step 5: Register the Component

Add the mapping in `config.lua`:

```{.lua filename="config.lua (addition)"}
['quote-card'] = { -- <1>
  wrapper = 'mcanouil-quote-card', -- <2>
  arguments = true -- <3>
}
```

1. Key is the CSS class name users write in markdown.
2. Value is the Typst function name to call.
3. Always pass arguments since quote cards typically have author/source.

Register the handler in `typst-markdown.lua`:

```{.lua filename="typst-markdown.lua (addition)"}
local quote_card = require( -- <1>
  quarto.utils.resolve_path('../_modules/quote-card.lua'):gsub('%.lua$', '')
)

local DIV_HANDLERS = {
  -- Existing handlers...
  ['quote-card'] = quote_card.process_div, -- <2>
}
```

1. Import the custom handler module.
2. Register handler function; key matches the class name in mappings.

### Step 6: Test the Component

Create a test document:

```{.markdown filename="test-quote-card.qmd"}
---
title: "Quote Card Test"
format:
  mcanouil-typst: default
---

## Using Attributes

::: {.quote-card author="Alan Kay" source="1971"}
The best way to predict the future is to invent it.
:::

## Using Heading

::: {.quote-card source="Keynote address"}
Any sufficiently advanced technology is indistinguishable from magic.

## Arthur C. Clarke
:::
```

Render with `quarto render test-quote-card.qmd` and verify the output.

### Development Workflow Summary

1. **Design syntax**: Decide how users will write the component.
2. **Create Typst function**: Build the rendering logic in `partials/libs/`.
3. **Create wrapper**: Add the colour-injecting wrapper to `typst-show.typ`.
4. **Create handler**: Use factory or custom handler in `_modules/`.
5. **Register mapping**: Add to built-in mappings in `config.lua`.
6. **Register handler**: Add to handler registry in `typst-markdown.lua`.
7. **Test thoroughly**: Verify with test documents in light and dark modes.

## Conclusion

### Design Principles Recap

Building sophisticated Quarto Typst extensions requires understanding several interconnected patterns:

1. **Dual-layer architecture**: Lua transforms document structure, Typst renders styled output.

2. **The RawBlock bridge**: `pandoc.RawBlock('typst', code)` connects the two layers.

3. **Wrapper functions**: Inject runtime context (colours, settings) that Lua cannot know at parse time.

4. **Handler factories**: Encapsulate common patterns for wrapped and atomic components.

5. **Configuration-driven design**: Enable extensibility through metadata-based mappings.

6. **Type-safe value conversion**: Always use dedicated functions for Lua-to-Typst conversion.

:::: {.highlight}

The separation of concerns between Lua (transformation) and Typst (rendering) enables flexibility, testability, and maintainability as your extension grows.

:::

### When to Use This Architecture

This dual-layer approach is most valuable when:

- You need styled components that adapt to document settings (colours, modes).
- Users should write familiar markdown syntax rather than raw Typst.
- Components require data extraction from nested structures.
- You want extensibility through configuration.

For simpler use cases, direct Typst templates may suffice.
The architecture described here pays dividends as complexity increases.

### Further Resources

- [Quarto Documentation: Creating Extensions](https://quarto.org/docs/extensions/creating.html)
- [Pandoc Lua Filters](https://pandoc.org/lua-filters.html)
- [Typst Documentation](https://typst.app/docs/)
- [quarto-mcanouil Extension](https://github.com/mcanouil/quarto-mcanouil)
- [R for the Rest of Us: Typst + Quarto](https://rfortherestofus.com/2025/11/quarto-typst-pdf)

*Happy templating!*
