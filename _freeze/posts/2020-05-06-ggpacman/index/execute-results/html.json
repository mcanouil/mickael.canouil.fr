{
  "hash": "e7d0d4c3cd1fc6836b722b8a60a9743f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"A `ggplot2` and `gganimate` Version of Pac-Man\"\ndescription: \"The story of `ggpacman`. Or how to build a useless but fun R package to make a GIF of the game Pac-Man.\"\ndate: \"2020-05-06\"\ncategories: [R, Visualisation, ggplot2, gganimate, Fun]\nimage: featured.png\nimage-alt: |\n  `ggpacman` hexagonal logo representing a red ghost from the game Pac-Man on a black background with a blue border and `ggpacman` written in yellow below the ghost.\nknitr:\n  opts_chunk:\n    dev: \"ragg_png\"\n    dev.args: {background: \"#ffffff00\"}\naliases:\n  - /post/ggpacman/index.html\n  - /post/ggpacman.html\n---\n\n\n\n## The Story of `ggpacman`\n\n![](featured.png){fig-alt=\"`ggpacman` hexagonal logo representing a red ghost from the game Pac-Man on a black background with a blue border and `ggpacman` written in yellow below the ghost.\" fig-align=\"center\"}\n\nIt started on a Saturday evening ...\n\nIt was the 21<sup>st</sup> of March (*for the sake of precision*),\naround 10 pm CET (*also for the sake of precision and mostly because it is not relevant*).\nI was playing around with my data on 'all' the movies I have seen so far ([mcanouil/imdb-ratings](https://github.com/mcanouil/imdb-ratings)) and looking on possibly new ideas of visualisation on twitter using `#ggplot2` and `#gganimate` (by the way the first time I played with [`gganimate`](https://gganimate.com/) was at [useR-2018 (Brisbane, Australia)](https://www.r-project.org/conferences/useR-2018/), just before and when @thomasp85 released the actual framework).\nThe only thing on the feed was \"contaminated/deaths and covid-19\" curves made with [`ggplot2`](https://ggplot2.tidyverse.org/) and a few with [`gganimate`](https://gganimate.com/) ...\nLet's say, it was not as funny and interesting as I was hoping for ...\nThen, I've got an idea, what if I can do something funny and not expected with [`ggplot2`](https://ggplot2.tidyverse.org/) and [`gganimate`](https://gganimate.com/)?\nMy first thought, was let's draw and animate Pac-Man, that should not be that hard!\n\nWell, it was not that easy after-all ...\nBut, I am going to go through my code here (you might be interested to actually look at the [commits history](https://github.com/mcanouil/ggpacman/commits/master).\n\n::: {.hcenter}\n\n<!-- <blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Maybe I went too far with <a href=\"https://twitter.com/hashtag/ggplot2?src=hash&amp;ref_src=twsrc%5Etfw\">#ggplot2</a> and <a href=\"https://twitter.com/hashtag/gganimate?src=hash&amp;ref_src=twsrc%5Etfw\">#gganimate</a> ...ðŸ˜…<br>What do you think <a href=\"https://twitter.com/hadleywickham?ref_src=twsrc%5Etfw\">@hadleywickham</a> &amp; <a href=\"https://twitter.com/thomasp85?ref_src=twsrc%5Etfw\">@thomasp85</a> , did I go too far or not enough ? (I am planning to add the ghosts ðŸ˜Ž) <a href=\"https://t.co/nkfbti1Etd\">pic.twitter.com/nkfbti1Etd</a></p>&mdash; MickaÃ«l CANOUIL (@MickaelCanouil) <a href=\"https://twitter.com/mickaelcanouil/status/1241760925499170824?ref_src=twsrc%5Etfw\">March 22, 2020</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script> -->\n\n<img src=\"media/tweet-1.png\" alt=\"Tweet: Maybe I went too far with ggplot2 and gganimate ... ðŸ˜… What do you \\@hadleywickham & \\@thomasp85, did I go too far or not enough ? (I am planning to add the ghosts ðŸ˜Ž) followed by an GIF of a PacMan moving in a labyrinth\" style=\"width: 550px;\" class=\"img-fluid\"/>\n\n:::\n\n## The R packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"stats\")\nlibrary(\"utils\")\nlibrary(\"rlang\")\nlibrary(\"magrittr\")\nlibrary(\"dplyr\")\nlibrary(\"tidyr\")\nlibrary(\"purrr\")\nlibrary(\"ggplot2\")\nlibrary(\"ggforce\")\nlibrary(\"gganimate\")\nlibrary(\"ggtext\")\n```\n:::\n\n\n## The maze layer\n\n### The base layer\n\nFirst thing first, I needed to set-up the base layer, meaning, the maze from Pac-Man.\nI did start by setting the coordinates of the maze.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer <- ggplot() +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"black\", colour = \"black\"),\n    panel.background = element_rect(fill = \"black\", colour = \"black\"),\n  ) +\n  coord_fixed(xlim = c(0, 20), ylim = c(0, 26))\n```\n:::\n\n\nFor later use, I defined some scales (actually those scales, where defined way after chronologically speaking).\nI am using those to define sizes and colours for all the geometries I am going to use to achieve the Pac-Man GIF.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_colours <- c(\n  \"READY!\" = \"goldenrod1\",\n  \"wall\" = \"dodgerblue3\", \"door\" = \"dodgerblue3\",\n  \"normal\" = \"goldenrod1\", \"big\" = \"goldenrod1\", \"eaten\" = \"black\",\n  \"Pac-Man\" = \"yellow\",\n  \"eye\" = \"white\", \"iris\" = \"black\",\n  \"Blinky\" = \"red\", \"Blinky_weak\" = \"blue\", \"Blinky_eaten\" = \"transparent\",\n  \"Pinky\" = \"pink\", \"Pinky_weak\" = \"blue\", \"Pinky_eaten\" = \"transparent\",\n  \"Inky\" = \"cyan\", \"Inky_weak\" = \"blue\", \"Inky_eaten\" = \"transparent\",\n  \"Clyde\" = \"orange\", \"Clyde_weak\" = \"blue\", \"Clyde_eaten\" = \"transparent\"\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer <- base_layer +\n  scale_size_manual(values = c(\"wall\" = 2.5, \"door\" = 1, \"big\" = 2.5, \"normal\" = 0.5, \"eaten\" = 3)) +\n  scale_fill_manual(breaks = names(map_colours), values = map_colours) +\n  scale_colour_manual(breaks = names(map_colours), values = map_colours)\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/base-layer-colours-print-1.png){width=672}\n:::\n:::\n\n\nMy `base_layer` here is not really helpful, so I temporarily added some elements to help me draw everything on it.\n*Note*: I won't use it in the following.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  scale_x_continuous(breaks = 0:21, sec.axis = dup_axis()) +\n  scale_y_continuous(breaks = 0:26, sec.axis = dup_axis()) +\n  theme(\n    panel.grid.major = element_line(colour = \"white\"),\n    axis.text = element_text(colour = \"white\")\n  ) +\n  annotate(\"rect\", xmin = 0, xmax = 21, ymin = 0, ymax = 26, fill = NA)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-layer-dev-1.png){width=672}\n:::\n:::\n\n\nQuite better, isn't it?!\n\n### The grid layer\n\nHere, I am calling \"grid\", the walls of the maze.\nFor this grid, I started drawing the vertical lines on the left side of the maze (as you may have noticed, the first level is symmetrical).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_vertical_segments <- tribble(\n  ~x, ~y, ~xend, ~yend,\n  0, 0, 0, 9,\n  0, 17, 0, 26,\n  2, 4, 2, 5,\n  2, 19, 2, 20,\n  2, 22, 2, 24,\n  4, 4, 4, 7,\n  4, 9, 4, 12,\n  4, 14, 4, 17,\n  4, 19, 4, 20,\n  4, 22, 4, 24,\n  6, 2, 6, 5,\n  6, 9, 6, 12,\n  6, 14, 6, 20,\n  6, 22, 6, 24,\n  8, 4, 8, 5,\n  8, 9, 8, 10,\n  8, 12, 8, 15,\n  8, 19, 8, 20,\n  8, 22, 8, 24\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  geom_segment(\n    data = left_vertical_segments,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend),\n    lineend = \"round\",\n    inherit.aes = FALSE,\n    colour = \"white\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/left-vertical-plot-1.png){width=672}\n:::\n:::\n\n\nThen, I added the horizontal lines (still only on the left side of the maze)!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_horizontal_segments <- tribble(\n  ~x, ~y, ~xend, ~yend,\n  0, 0, 10, 0,\n  2, 2, 8, 2,\n  0, 4, 2, 4,\n  8, 4, 10, 4,\n  0, 5, 2, 5,\n  8, 5, 10, 5,\n  2, 7, 4, 7,\n  6, 7, 8, 7,\n  0, 9, 4, 9,\n  8, 9, 10, 9,\n  8, 10, 10, 10,\n  0, 12, 4, 12,\n  8, 12, 10, 12,\n  0, 14, 4, 14,\n  8, 15, 9, 15,\n  0, 17, 4, 17,\n  6, 17, 8, 17,\n  2, 19, 4, 19,\n  8, 19, 10, 19,\n  2, 20, 4, 20,\n  8, 20, 10, 20,\n  2, 22, 4, 22,\n  6, 22, 8, 22,\n  2, 24, 4, 24,\n  6, 24, 8, 24,\n  0, 26, 10, 26\n)\n\nleft_segments <- bind_rows(left_vertical_segments, left_horizontal_segments)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  geom_segment(\n    data = left_segments,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend),\n    lineend = \"round\",\n    inherit.aes = FALSE,\n    colour = \"white\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/left-plot-1.png){width=672}\n:::\n:::\n\n\nThe maze is slowly appearing, but surely.\nAs I wrote earlier, the first level is symmetrical, so I used my left lines `left_segments` to compute all the lines on the right `right_segments`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_segments <-  mutate(\n  .data = left_segments,\n  x = abs(x - 20),\n  xend = abs(xend - 20)\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  geom_segment(\n    data = bind_rows(left_segments, right_segments),\n    mapping = aes(x = x, y = y, xend = xend, yend = yend),\n    lineend = \"round\",\n    inherit.aes = FALSE,\n    colour = \"white\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/right-plot-1.png){width=672}\n:::\n:::\n\n\nThe middle vertical lines were missing, *i.e.*, I did not want to plot them twice, which would have happen, if I added these in `left_segments`.\nAlso, the \"door\" of the ghost spawn area is missing.\nI added the door and the missing vertical walls in the end.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentre_vertical_segments <- tribble(\n  ~x, ~y, ~xend, ~yend,\n  10, 2, 10, 4,\n  10, 7, 10, 9,\n  10, 17, 10, 19,\n  10, 22, 10, 26\n)\ndoor_segment <- tibble(x = 9, y = 15, xend = 11, yend = 15, type = \"door\")\n```\n:::\n\n\nFinally, I combined all the segments and drew them all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze_walls <- bind_rows(\n  left_segments,\n  centre_vertical_segments,\n  right_segments\n) %>%\n  mutate(type = \"wall\") %>%\n  bind_rows(door_segment)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  geom_segment(\n    data = maze_walls,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend),\n    lineend = \"round\",\n    inherit.aes = FALSE,\n    colour = \"white\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/maze-plot-1.png){width=672}\n:::\n:::\n\n\nThe maze is now complete, but no-one can actually see the door, since it appears the same way as the walls.\nYou may have noticed, I added a column named `type`.\n`type` can currently hold two values: `\"wall\"` and `\"door\"`.\nI am going to use `type` as values for two aesthetics, you may already have guessed which ones.\nThe answer is the `colour` and `size` aesthetics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_layer +\n  geom_segment(\n    data = maze_walls,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend, colour = type, size = type),\n    lineend = \"round\",\n    inherit.aes = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/maze-plot-colour-1.png){width=672}\n:::\n:::\n\n\n*Note: `maze_walls` is a dataset of `ggpacman` (`data(\"maze_walls\", package = \"ggpacman\")`).*\n\n### The bonus points layer\n\nThe strategy was quite the same as for the grid layer:\n\n- Setting up the point coordinates for the left side and the middle.\n- Compute the coordinates for the right side.\n- Use a column `type` for the two types of bonus points, *i.e.*, `\"normal\"` and `\"big\"` (the one who weaken the ghosts).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbonus_points_coord <- function() {\n  left_bonus_points <- tribble(\n    ~x, ~y, ~type,\n    1, c(1:3, 7:8, 18:22, 24:25), \"normal\",\n    1, c(6, 23), \"big\",\n    2, c(1, 3, 6, 8, 18, 21, 25), \"normal\",\n    3, c(1, 3:6, 8, 18, 21, 25), \"normal\",\n    4, c(1, 3, 8, 18, 21, 25), \"normal\",\n    5, c(1, 3:25), \"normal\",\n    6, c(1, 6, 8, 21, 25), \"normal\",\n    7, c(1, 3:6, 8, 18:21, 25), \"normal\",\n    8, c(1, 3, 6, 8, 18, 21, 25), \"normal\",\n    9, c(1:3, 6:8, 18, 21:25), \"normal\"\n  )\n\n  bind_rows(\n    left_bonus_points,\n    tribble(\n      ~x, ~y, ~type,\n      10, c(1, 21), \"normal\"\n    ),\n    mutate(left_bonus_points, x = abs(x - 20))\n  ) %>%\n    unnest(\"y\")\n}\nmaze_points <- bonus_points_coord()\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze_layer <- base_layer +\n  geom_segment(\n    data = maze_walls,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend, colour = type, size = type),\n    lineend = \"round\",\n    inherit.aes = FALSE\n  ) +\n  geom_point(\n    data = maze_points,\n    mapping = aes(x = x, y = y, size = type, colour = type),\n    inherit.aes = FALSE\n  )\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/maze-point-plot-print-1.png){width=672}\n:::\n:::\n\n\n*Note: `maze_points` is a dataset of `ggpacman` (`data(\"maze_points\", package = \"ggpacman\")`).*\n\n## Pac-Man character\n\nIt is now time to draw the main character.\nTo draw Pac-Man, I needed few things:\n\n- The Pac-Man moves, *i.e.*, all the coordinates where Pac-Man is supposed to be at every `step`.\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  data(\"pacman\", package = \"ggpacman\")\n  unnest(pacman, c(\"x\", \"y\"))\n  #> # A tibble: 150 Ã— 3\n  #>        x     y colour \n  #>    <dbl> <dbl> <chr>  \n  #>  1    10     6 Pac-Man\n  #>  2    10     6 Pac-Man\n  #>  3    10     6 Pac-Man\n  #>  4    10     6 Pac-Man\n  #>  5    10     6 Pac-Man\n  #>  6    10     6 Pac-Man\n  #>  7    10     6 Pac-Man\n  #>  8    10     6 Pac-Man\n  #>  9    10     6 Pac-Man\n  #> 10    10     6 Pac-Man\n  #> # â„¹ 140 more rows\n  ```\n  :::\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  maze_layer +\n    geom_point(\n      data = unnest(pacman, c(\"x\", \"y\")),\n      mapping = aes(x = x, y = y, colour = colour),\n      size = 4\n    )\n  ```\n  \n  ::: {.cell-output-display}\n  ![](index_files/figure-html/pacman-position-plot-1.png){width=672}\n  :::\n  :::\n\n\n- The Pac-Man shape (open and closed mouth). Since, Pac-Man is not a complete circle shape, I used `geom_arc_bar()` (from [`ggforce`](https://ggforce.data-imaginist.com/)), and defined the properties of each state of Pac-Man based on the aesthetics required by this function.\n  *Note*: At first, I wanted a smooth animation/transition ofPac-Man opening and closing its mouth, this is why there arefour `\"close_\"` states.\n  \n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  pacman_state <- tribble(\n    ~state, ~start, ~end,\n    \"open_right\", 14 / 6 * pi, 4 / 6 * pi,\n    \"close_right\", 15 / 6 * pi, 3 / 6 * pi,\n    \"open_up\", 11 / 6 * pi, 1 / 6 * pi,\n    \"close_up\", 12 / 3 * pi, 0 / 6 * pi,\n    \"open_left\", 8 / 6 * pi, - 2 / 6 * pi,\n    \"close_left\", 9 / 6 * pi, - 3 / 6 * pi,\n    \"open_down\", 5 / 6 * pi, - 5 / 6 * pi,\n    \"close_down\", pi, - pi\n  )\n  ```\n  :::\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  ggplot() +\n    geom_arc_bar(\n      data = pacman_state,\n      mapping = aes(x0 = 0, y0 = 0, r0 = 0, r = 0.5, start =start, end = end),\n      fill = \"yellow\",\n      inherit.aes = FALSE\n    ) +\n    facet_wrap(vars(state), ncol = 4)\n  ```\n  \n  ::: {.cell-output-display}\n  ![](index_files/figure-html/pacman-state-plot-1.png){width=672}\n  :::\n  :::\n\n\n::: {.hcenter}\n\n<!-- <blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">Next mission, should you choose to accept, is to make Pac-Man face the direction of movementðŸŽ–</p>&mdash; Thomas Lin Pedersen (@thomasp85) <a href=\"https://twitter.com/thomasp85/status/1241767912370774020?ref_src=twsrc%5Etfw\">March 22, 2020</a></blockquote> -->\n\n<img src=\"media/tweet-2.png\" alt=\"Tweet: Next mission, should you choose to accept, is to make Pac-Man face the direction of movement &mdash; Thomas Lin Pedersen (\\@thomasp85)\" style=\"width: 550px;\" class=\"img-fluid\"/>\n\n:::\n\nOnce those things available, how to make Pac-Man look where he is headed?\nShort answer, I just computed the differences between two successive positions of Pac-Man and added both open/close state to a new column `state`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman %>%\n  unnest(c(\"x\", \"y\")) %>%\n  mutate(\n    state_x = sign(x - lag(x)),\n    state_y = sign(y - lag(y)),\n    state = case_when(\n      (is.na(state_x) | state_x %in% 0) & (is.na(state_y) | state_y %in% 0) ~ list(c(\"open_right\", \"close_right\")),\n      state_x == 1 & state_y == 0 ~ list(c(\"open_right\", \"close_right\")),\n      state_x == -1 & state_y == 0 ~ list(c(\"open_left\", \"close_left\")),\n      state_x == 0 & state_y == -1 ~ list(c(\"open_down\", \"close_down\")),\n      state_x == 0 & state_y == 1 ~ list(c(\"open_up\", \"close_up\"))\n    )\n  )  %>%\n  unnest(\"state\")\n#> # A tibble: 300 Ã— 6\n#>        x     y colour  state_x state_y state      \n#>    <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>      \n#>  1    10     6 Pac-Man      NA      NA open_right \n#>  2    10     6 Pac-Man      NA      NA close_right\n#>  3    10     6 Pac-Man       0       0 open_right \n#>  4    10     6 Pac-Man       0       0 close_right\n#>  5    10     6 Pac-Man       0       0 open_right \n#>  6    10     6 Pac-Man       0       0 close_right\n#>  7    10     6 Pac-Man       0       0 open_right \n#>  8    10     6 Pac-Man       0       0 close_right\n#>  9    10     6 Pac-Man       0       0 open_right \n#> 10    10     6 Pac-Man       0       0 close_right\n#> # â„¹ 290 more rows\n```\n:::\n\n\nHere, in preparation for [`gganimate`](https://gganimate.com/), I also added a column `step` before merging the new upgraded `pacman` (*i.e.*, with the Pac-Man `state` column) with the `pacman_state` defined earlier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman_moves <- ggpacman::compute_pacman_coord(pacman)\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 300 Ã— 9\n#>        x     y colour  state_x state_y state        step start   end\n#>    <dbl> <dbl> <chr>     <dbl>   <dbl> <chr>       <int> <dbl> <dbl>\n#>  1    10     6 Pac-Man      NA      NA open_right      1  7.33  2.09\n#>  2    10     6 Pac-Man      NA      NA close_right     2  7.85  1.57\n#>  3    10     6 Pac-Man       0       0 open_right      3  7.33  2.09\n#>  4    10     6 Pac-Man       0       0 close_right     4  7.85  1.57\n#>  5    10     6 Pac-Man       0       0 open_right      5  7.33  2.09\n#>  6    10     6 Pac-Man       0       0 close_right     6  7.85  1.57\n#>  7    10     6 Pac-Man       0       0 open_right      7  7.33  2.09\n#>  8    10     6 Pac-Man       0       0 close_right     8  7.85  1.57\n#>  9    10     6 Pac-Man       0       0 open_right      9  7.33  2.09\n#> 10    10     6 Pac-Man       0       0 close_right    10  7.85  1.57\n#> # â„¹ 290 more rows\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze_layer +\n  geom_arc_bar(\n    data = pacman_moves,\n    mapping = aes(x0 = x, y0 = y, r0 = 0, r = 0.5, start = start, end = end, colour = colour, fill = colour, group = step),\n    inherit.aes = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/pacman-moves-plots-1.png){width=672}\n:::\n:::\n\n\nYou can't see much?!\nOk, perhaps it's time to use [`gganimate`](https://gganimate.com/).\nI am going to animate Pac-Man based on the column `step`, which is, if you looked at the code above, just the line number of `pacman_moves`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimated_pacman <- maze_layer +\n  geom_arc_bar(\n    data = pacman_moves,\n    mapping = aes(x0 = x, y0 = y, r0 = 0, r = 0.5, start = start, end = end, colour = colour, fill = colour, group = step),\n    inherit.aes = FALSE\n  ) +\n  transition_manual(step)\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/pacman-plot-animated-1.gif)\n:::\n:::\n\n\n*Note: `pacman` is a dataset of `ggpacman` (`data(\"pacman\", package = \"ggpacman\")`).*\n\n## The Ghosts characters\n\nTime to draw the ghosts, namely: Blinky, Pinky, Inky and Clyde.\n\n### Body\n\nI started with the body, especially the top and the bottom part of the ghost which are half circle (or at least I chose this) and use again `geom_arc_bar()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nghost_arc <- tribble(\n  ~x0, ~y0, ~r, ~start, ~end, ~part,\n  0, 0, 0.5, - 1 * pi / 2, 1 * pi / 2, \"top\",\n  -0.5, -0.5 + 1/6, 1 / 6,  pi / 2, 2 * pi / 2, \"bottom\",\n  -1/6, -0.5 + 1/6, 1 / 6,  pi / 2, 3 * pi / 2, \"bottom\",\n  1/6, -0.5 + 1/6, 1 / 6,  pi / 2, 3 * pi / 2, \"bottom\",\n  0.5, -0.5 + 1/6, 1 / 6,  3 * pi / 2,  2 * pi / 2, \"bottom\"\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop <- ggplot() +\n  geom_arc_bar(\n    data = ghost_arc[1, ],\n    mapping = aes(x0 = x0, y0 = y0, r0 = 0, r = r, start = start, end = end)\n  ) +\n  coord_fixed(xlim = c(-1, 1), ylim = c(-1, 1))\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/ghost-top-plot-1.png){width=672}\n:::\n:::\n\n\nI retrieved the coordinates of the created polygon, using `ggplot_build()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_polygon <- ggplot_build(top)$data[[1]][, c(\"x\", \"y\")]\n```\n:::\n\n\nAnd I proceeded the same way for the bottom part of the ghost.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbottom <- ggplot() +\n  geom_arc_bar(\n    data = ghost_arc[-1, ],\n\t\tmapping = aes(x0 = x0, y0 = y0, r0 = 0, r = r, start = start, end = end)\n  ) +\n  coord_fixed(xlim = c(-1, 1), ylim = c(-1, 1))\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/ghost-bottom-plot-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbottom_polygon <- ggplot_build(bottom)$data[[1]][, c(\"x\", \"y\")]\n```\n:::\n\n\nThen, I just added one point to \"properly\" link the top and the bottom part.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nghost_body <- dplyr::bind_rows(\n  top_polygon,\n  dplyr::tribble(\n    ~x, ~y,\n    0.5, 0,\n    0.5, -0.5 + 1/6\n  ),\n  bottom_polygon,\n  dplyr::tribble(\n    ~x, ~y,\n    -0.5, -0.5 + 1/6,\n    -0.5, 0\n  )\n)\n```\n:::\n\n\nI finally got the whole ghost shape I was looking for.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  coord_fixed(xlim = c(-1, 1), ylim = c(-1, 1)) +\n  geom_polygon(\n    data = ghost_body,\n    mapping = aes(x = x, y = y),\n    inherit.aes = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ghost-body-plot-1.png){width=672}\n:::\n:::\n\n\n*Note: `ghost_body` is a dataset of `ggpacman` (`data(\"ghost_body\", package = \"ggpacman\")`).*  \n*Note: `ghost_body` definitely needs some code refactoring.*\n\n### Eyes\n\nThe eyes are quite easy to draw, they are just circles, but ...\nAs for Pac-Man before, I wanted the ghosts to look where they are headed.\nThis implies moving the iris one way or the other, and so I defined five states for the iris: right, down, left, up and middle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nghost_eyes <- tribble(\n  ~x0, ~y0, ~r, ~part, ~direction,\n  1/5, 1/8, 1/8, \"eye\", c(\"up\", \"down\", \"right\", \"left\", \"middle\"),\n  -1/5, 1/8, 1/8, \"eye\", c(\"up\", \"down\", \"right\", \"left\", \"middle\"),\n  5/20, 1/8, 1/20, \"iris\", \"right\",\n  -3/20, 1/8, 1/20, \"iris\", \"right\",\n  1/5, 1/16, 1/20, \"iris\", \"down\",\n  -1/5, 1/16, 1/20, \"iris\", \"down\",\n  3/20, 1/8, 1/20, \"iris\", \"left\",\n  -5/20, 1/8, 1/20, \"iris\", \"left\",\n  1/5, 3/16, 1/20, \"iris\", \"up\",\n  -1/5, 3/16, 1/20, \"iris\", \"up\",\n  1/5, 1/8, 1/20, \"iris\", \"middle\",\n  -1/5, 1/8, 1/20, \"iris\", \"middle\"\n) %>%\n  unnest(\"direction\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_eyes <- c(\"eye\" = \"white\", \"iris\" = \"black\")\nggplot() +\n  coord_fixed(xlim = c(-0.5, 0.5), ylim = c(-0.5, 0.5)) +\n  scale_fill_manual(breaks = names(map_eyes), values = map_eyes) +\n  scale_colour_manual(breaks = names(map_eyes), values = map_eyes) +\n  geom_circle(\n    data = ghost_eyes,\n    mapping = aes(x0 = x0, y0 = y0, r = r, colour = part, fill = part),\n    inherit.aes = FALSE,\n    show.legend = FALSE\n  ) +\n  facet_wrap(vars(direction), ncol = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ghost-eyes-plot-1.png){width=672}\n:::\n:::\n\n\n*Note: `ghost_eyes` is a dataset of `ggpacman` (`data(\"ghost_eyes\", package = \"ggpacman\")`).*\n\n### Ghost shape\n\nI had the whole ghost shape and the eyes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  coord_fixed(xlim = c(-1, 1), ylim = c(-1, 1)) +\n  scale_fill_manual(breaks = names(map_colours), values = map_colours) +\n  scale_colour_manual(breaks = names(map_colours), values = map_colours) +\n  geom_polygon(\n    data = get(data(\"ghost_body\", package = \"ggpacman\")),\n    mapping = aes(x = x, y = y),\n    inherit.aes = FALSE\n  ) +\n  geom_circle(\n    data = get(data(\"ghost_eyes\", package = \"ggpacman\")),\n    mapping = aes(x0 = x0, y0 = y0, r = r, colour = part, fill = part),\n    inherit.aes = FALSE,\n    show.legend = FALSE\n  ) +\n  facet_wrap(vars(direction), ncol = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ghost-shape-plot-1.png){width=672}\n:::\n:::\n\n\nAgain, same as for Pac-Man, in order to know where the ghosts are supposed to look, I computed the differences of each successive positions of the ghosts and I added the corresponding directions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_ghost <- tibble(x = c(0, 1, 1, 0, 0), y = c(0, 0, 1, 1, 0), colour = \"Blinky\") %>%\n  unnest(c(\"x\", \"y\")) %>%\n  mutate(\n    X0 = x,\n    Y0 = y,\n    state_x = sign(round(x) - lag(round(x))),\n    state_y = sign(round(y) - lag(round(y))),\n    direction = case_when(\n      (is.na(state_x) | state_x %in% 0) & (is.na(state_y) | state_y %in% 0) ~ \"middle\",\n      state_x == 1 & state_y == 0 ~ \"right\",\n      state_x == -1 & state_y == 0 ~ \"left\",\n      state_x == 0 & state_y == -1 ~ \"down\",\n      state_x == 0 & state_y == 1 ~ \"up\"\n    )\n  ) %>%\n  unnest(\"direction\")\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 5 Ã— 8\n#>       x     y colour    X0    Y0 state_x state_y direction\n#>   <dbl> <dbl> <chr>  <dbl> <dbl>   <dbl>   <dbl> <chr>    \n#> 1     0     0 Blinky     0     0      NA      NA middle   \n#> 2     1     0 Blinky     1     0       1       0 right    \n#> 3     1     1 Blinky     1     1       0       1 up       \n#> 4     0     1 Blinky     0     1      -1       0 left     \n#> 5     0     0 Blinky     0     0       0      -1 down\n```\n:::\n\n\nI also added some noise around the position, *i.e.*, four noised position at each actual position of a ghost.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_ghost <- blinky_ghost %>%\n  mutate(state = list(1:4)) %>%\n  unnest(\"state\") %>%\n  mutate(\n    step = 1:n(),\n    noise_x = rnorm(n(), mean = 0, sd = 0.05),\n    noise_y = rnorm(n(), mean = 0, sd = 0.05)\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 20 Ã— 12\n#>        x     y colour    X0    Y0 state_x state_y direction state  step  noise_x\n#>    <dbl> <dbl> <chr>  <dbl> <dbl>   <dbl>   <dbl> <chr>     <int> <int>    <dbl>\n#>  1     0     0 Blinky     0     0      NA      NA middle        1     1 -0.00237\n#>  2     0     0 Blinky     0     0      NA      NA middle        2     2 -0.107  \n#>  3     0     0 Blinky     0     0      NA      NA middle        3     3 -0.0608 \n#>  4     0     0 Blinky     0     0      NA      NA middle        4     4 -0.0696 \n#>  5     1     0 Blinky     1     0       1       0 right         1     5  0.0394 \n#>  6     1     0 Blinky     1     0       1       0 right         2     6 -0.00189\n#>  7     1     0 Blinky     1     0       1       0 right         3     7 -0.0214 \n#>  8     1     0 Blinky     1     0       1       0 right         4     8 -0.00565\n#>  9     1     1 Blinky     1     1       0       1 up            1     9  0.0294 \n#> 10     1     1 Blinky     1     1       0       1 up            2    10 -0.0300 \n#> 11     1     1 Blinky     1     1       0       1 up            3    11  0.0501 \n#> 12     1     1 Blinky     1     1       0       1 up            4    12 -0.0399 \n#> 13     0     1 Blinky     0     1      -1       0 left          1    13  0.0380 \n#> 14     0     1 Blinky     0     1      -1       0 left          2    14  0.0687 \n#> 15     0     1 Blinky     0     1      -1       0 left          3    15 -0.00772\n#> 16     0     1 Blinky     0     1      -1       0 left          4    16 -0.0686 \n#> 17     0     0 Blinky     0     0       0      -1 down          1    17  0.0395 \n#> 18     0     0 Blinky     0     0       0      -1 down          2    18 -0.0493 \n#> 19     0     0 Blinky     0     0       0      -1 down          3    19 -0.0348 \n#> 20     0     0 Blinky     0     0       0      -1 down          4    20 -0.0444 \n#> # â„¹ 1 more variable: noise_y <dbl>\n```\n:::\n\n\nThen, I added (*in a weird way I might say*) the polygons coordinates for the body and the eyes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_ghost <- blinky_ghost %>%\n  mutate(\n    body = pmap(\n      .l = list(x, y, noise_x, noise_y),\n      .f = function(.x, .y, .noise_x, .noise_y) {\n        mutate(\n          .data = get(data(\"ghost_body\")),\n          x = x + .x + .noise_x,\n          y = y + .y + .noise_y\n        )\n      }\n    ),\n    eyes = pmap(\n      .l = list(x, y, noise_x, noise_y, direction),\n      .f = function(.x, .y, .noise_x, .noise_y, .direction) {\n        mutate(\n          .data = filter(get(data(\"ghost_eyes\")), direction == .direction),\n          x0 = x0 + .x + .noise_x,\n          y0 = y0 + .y + .noise_y,\n          direction = NULL\n        )\n      }\n    ),\n    x = NULL,\n    y = NULL\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 20 Ã— 12\n#>    colour    X0    Y0 state_x state_y direction state  step  noise_x  noise_y\n#>    <chr>  <dbl> <dbl>   <dbl>   <dbl> <chr>     <int> <int>    <dbl>    <dbl>\n#>  1 Blinky     0     0      NA      NA middle        1     1 -0.00237 -0.0956 \n#>  2 Blinky     0     0      NA      NA middle        2     2 -0.107    0.0117 \n#>  3 Blinky     0     0      NA      NA middle        3     3 -0.0608  -0.102  \n#>  4 Blinky     0     0      NA      NA middle        4     4 -0.0696   0.0827 \n#>  5 Blinky     1     0       1       0 right         1     5  0.0394   0.0279 \n#>  6 Blinky     1     0       1       0 right         2     6 -0.00189 -0.0781 \n#>  7 Blinky     1     0       1       0 right         3     7 -0.0214  -0.0351 \n#>  8 Blinky     1     0       1       0 right         4     8 -0.00565  0.0535 \n#>  9 Blinky     1     1       0       1 up            1     9  0.0294   0.00978\n#> 10 Blinky     1     1       0       1 up            2    10 -0.0300   0.0134 \n#> 11 Blinky     1     1       0       1 up            3    11  0.0501   0.0297 \n#> 12 Blinky     1     1       0       1 up            4    12 -0.0399   0.0773 \n#> 13 Blinky     0     1      -1       0 left          1    13  0.0380   0.0257 \n#> 14 Blinky     0     1      -1       0 left          2    14  0.0687   0.0199 \n#> 15 Blinky     0     1      -1       0 left          3    15 -0.00772  0.0978 \n#> 16 Blinky     0     1      -1       0 left          4    16 -0.0686  -0.0706 \n#> 17 Blinky     0     0       0      -1 down          1    17  0.0395   0.00575\n#> 18 Blinky     0     0       0      -1 down          2    18 -0.0493   0.00515\n#> 19 Blinky     0     0       0      -1 down          3    19 -0.0348  -0.00375\n#> 20 Blinky     0     0       0      -1 down          4    20 -0.0444   0.0270 \n#> # â„¹ 2 more variables: body <list>, eyes <list>\n```\n:::\n\n\nFor ease, it is now a call to one function directly on the position matrix of a ghost.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_ghost <- tibble(x = c(0, 1, 1, 0, 0), y = c(0, 0, 1, 1, 0), colour = \"Blinky\")\nblinky_moves <- ggpacman::compute_ghost_coord(blinky_ghost)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_plot <- base_layer +\n  coord_fixed(xlim = c(-1, 2), ylim = c(-1, 2)) +\n  geom_polygon(\n    data = unnest(blinky_moves, \"body\"),\n    mapping = aes(x = x, y = y, fill = colour, colour = colour, group = step),\n    inherit.aes = FALSE\n  ) +\n  geom_circle(\n    data = unnest(blinky_moves, \"eyes\"),\n    mapping = aes(x0 = x0, y0 = y0, r = r, colour = part, fill = part, group = step),\n    inherit.aes = FALSE\n  )\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/blinky-plot-static-1.png){width=672}\n:::\n:::\n\n\nAgain, it is better with an animated GIF.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimated_blinky <- blinky_plot + transition_manual(step)\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/blinky-plot-animated-1.gif)\n:::\n:::\n\n\n## How Pac-Man interacts with the maze?\n\n### Bonus points\n\nFor ease, I am using some functions I defined to go quickly to the results of the first part of this readme.\nThe idea here is to look at all the position in common between Pac-Man (`pacman_moves`) and the bonus points (`maze_points`).\nEach time Pac-Man was at the same place as a bonus point, I defined a status `\"eaten\"` for all values of `step` after.\nI ended up with a big table with position and the state of the bonus points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman_moves <- ggpacman::compute_pacman_coord(get(data(\"pacman\", package = \"ggpacman\")))\nright_join(get(data(\"maze_points\")), pacman_moves, by = c(\"x\", \"y\")) %>%\n  distinct(step, x, y, type) %>%\n  mutate(\n    step = map2(step, max(step), ~ seq(.x, .y, 1)),\n    colour = \"eaten\"\n  ) %>%\n  unnest(\"step\")\n#> # A tibble: 45,150 Ã— 5\n#>     step     x     y type   colour\n#>    <dbl> <dbl> <dbl> <chr>  <chr> \n#>  1    61     1     1 normal eaten \n#>  2    62     1     1 normal eaten \n#>  3    63     1     1 normal eaten \n#>  4    64     1     1 normal eaten \n#>  5    65     1     1 normal eaten \n#>  6    66     1     1 normal eaten \n#>  7    67     1     1 normal eaten \n#>  8    68     1     1 normal eaten \n#>  9    69     1     1 normal eaten \n#> 10    70     1     1 normal eaten \n#> # â„¹ 45,140 more rows\n```\n:::\n\n\nAgain, for ease, I am using a function I defined to compute everything.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman_moves <- ggpacman::compute_pacman_coord(get(data(\"pacman\", package = \"ggpacman\")))\nbonus_points_eaten <- ggpacman::compute_points_eaten(get(data(\"maze_points\")), pacman_moves)\n```\n:::\n\n\nIf you don't recall, `maze_layer` already includes a geometry with the bonus points.\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/reminder-maze-1.png){width=672}\n:::\n:::\n\n\nI could have change this geometry (*i.e.*, `geom_point()`), but I did not, and draw a new geometry on top of the previous ones.\nDo you remember the values of the scale for the size aesthetic?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscale_size_manual(values = c(\"wall\" = 2.5, \"door\" = 1, \"big\" = 2.5, \"normal\" = 0.5, \"eaten\" = 3))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaze_layer_points <- maze_layer +\n  geom_point(\n    data = bonus_points_eaten,\n    mapping = aes(x = x, y = y, colour = colour, size = colour, group = step),\n    inherit.aes = FALSE\n  )\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/points-eaten-plot-1.png){width=672}\n:::\n:::\n\n\nA new animation to see, how the new geometry is overlapping the previous one as `step` increases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimated_points <- maze_layer_points + transition_manual(step)\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/points-eaten-plot-animated-1.gif)\n:::\n:::\n\n\n### Ghost `\"weak\"` and `\"eaten\"` states\n\nThe ghosts were more tricky (I know, they are ghosts ...).\n\nI first retrieved all the positions where a `\"big\"` bonus point was eaten by Pac-Man.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nghosts_vulnerability <- bonus_points_eaten %>%\n  filter(type == \"big\") %>%\n  group_by(x, y) %>%\n  summarise(step_init = min(step)) %>%\n  ungroup() %>%\n  mutate(\n    step = map(step_init, ~ seq(.x, .x + 30, 1)),\n    vulnerability = TRUE,\n    x = NULL,\n    y = NULL\n  ) %>%\n  unnest(\"step\")\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 93 Ã— 3\n#>    step_init  step vulnerability\n#>        <dbl> <dbl> <lgl>        \n#>  1        79    79 TRUE         \n#>  2        79    80 TRUE         \n#>  3        79    81 TRUE         \n#>  4        79    82 TRUE         \n#>  5        79    83 TRUE         \n#>  6        79    84 TRUE         \n#>  7        79    85 TRUE         \n#>  8        79    86 TRUE         \n#>  9        79    87 TRUE         \n#> 10        79    88 TRUE         \n#> # â„¹ 83 more rows\n```\n:::\n\n\nThis is part of a bigger function (I won't dive too deep into it).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggpacman::compute_ghost_status\n#> function(ghost, pacman_moves, bonus_points_eaten) {\n#>   ghosts_vulnerability <- bonus_points_eaten %>%\n#>     dplyr::filter(.data[[\"type\"]] == \"big\") %>%\n#>     dplyr::group_by(.data[[\"x\"]], .data[[\"y\"]]) %>%\n#>     dplyr::summarise(step_init = min(.data[[\"step\"]])) %>%\n#>     dplyr::ungroup() %>%\n#>     dplyr::mutate(\n#>       step = purrr::map(.data[[\"step_init\"]], ~ seq(.x, .x + 30, 1)),\n#>       vulnerability = TRUE,\n#>       x = NULL,\n#>       y = NULL\n#>     ) %>%\n#>     tidyr::unnest(\"step\")\n#> \n#>   ghost_out <- dplyr::left_join(\n#>     x = compute_ghost_coord(ghost),\n#>     y = pacman_moves %>%\n#>       dplyr::mutate(ghost_eaten = TRUE) %>%\n#>       dplyr::select(c(\"X0\" = \"x\", \"Y0\" = \"y\", \"step\", \"ghost_eaten\")),\n#>     by = c(\"X0\", \"Y0\", \"step\")\n#>   ) %>%\n#>     dplyr::left_join(y = ghosts_vulnerability, by = \"step\") %>%\n#>     dplyr::mutate(\n#>       vulnerability = tidyr::replace_na(.data[[\"vulnerability\"]], FALSE),\n#>       ghost_name = .data[[\"colour\"]],\n#>       ghost_eaten = .data[[\"ghost_eaten\"]] & .data[[\"vulnerability\"]],\n#>       colour = ifelse(.data[[\"vulnerability\"]], paste0(.data[[\"ghost_name\"]], \"_weak\"), .data[[\"colour\"]])\n#>     )\n#> \n#>   pos_eaten_start <- which(ghost_out[[\"ghost_eaten\"]])\n#>   ghosts_home <- which(ghost_out[[\"X0\"]] == 10 & ghost_out[[\"Y0\"]] == 14)\n#>   for (ipos in pos_eaten_start) {\n#>     pos_eaten_end <- min(ghosts_home[ghosts_home>=ipos])\n#>     ghost_out[[\"colour\"]][ipos:pos_eaten_end] <- paste0(unique(ghost_out[[\"ghost_name\"]]), \"_eaten\")\n#>   }\n#> \n#>   dplyr::left_join(\n#>     x = ghost_out,\n#>     y = ghost_out %>%\n#>       dplyr::filter(.data[[\"step\"]] == .data[[\"step_init\"]] & grepl(\"eaten\", .data[[\"colour\"]])) %>%\n#>       dplyr::mutate(already_eaten = TRUE) %>%\n#>       dplyr::select(c(\"step_init\", \"already_eaten\")),\n#>       by = \"step_init\"\n#>   ) %>%\n#>     dplyr::mutate(\n#>       colour = dplyr::case_when(\n#>         .data[[\"already_eaten\"]] & .data[[\"X0\"]] == 10 & .data[[\"Y0\"]] == 14 ~ paste0(.data[[\"ghost_name\"]], \"_eaten\"),\n#>         grepl(\"weak\", .data[[\"colour\"]]) & .data[[\"already_eaten\"]] ~ .data[[\"ghost_name\"]],\n#>         TRUE ~ .data[[\"colour\"]]\n#>       )\n#>     )\n#> }\n#> <bytecode: 0x160c1d560>\n#> <environment: namespace:ggpacman>\n```\n:::\n\n\nThe goal of this function, is to compute the different states of a ghost, according to the bonus points eaten and, of course, the current Pac-Man position at a determined `step`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman_moves <- ggpacman::compute_pacman_coord(get(data(\"pacman\", package = \"ggpacman\")))\nbonus_points_eaten <- ggpacman::compute_points_eaten(get(data(\"maze_points\")), pacman_moves)\nghost_moves <- ggpacman::compute_ghost_status(\n  ghost = get(data(\"blinky\", package = \"ggpacman\")),\n  pacman_moves = pacman_moves,\n  bonus_points_eaten = bonus_points_eaten\n)\nghost_moves %>%\n  filter(state == 1) %>%\n  distinct(step, direction, colour, vulnerability) %>%\n  as.data.frame()\n#>    step direction       colour vulnerability\n#> 1     1    middle       Blinky         FALSE\n#> 2     5    middle       Blinky         FALSE\n#> 3     9    middle       Blinky         FALSE\n#> 4    13    middle       Blinky         FALSE\n#> 5    17    middle       Blinky         FALSE\n#> 6    21    middle       Blinky         FALSE\n#> 7    25    middle       Blinky         FALSE\n#> 8    29    middle       Blinky         FALSE\n#> 9    33    middle       Blinky         FALSE\n#> 10   37      left       Blinky         FALSE\n#> 11   41      left       Blinky         FALSE\n#> 12   45      left       Blinky         FALSE\n#> 13   49      down       Blinky         FALSE\n#> 14   53      down       Blinky         FALSE\n#> 15   57      down       Blinky         FALSE\n#> 16   61      left       Blinky         FALSE\n#> 17   65      left       Blinky         FALSE\n#> 18   69      down       Blinky         FALSE\n#> 19   73      down       Blinky         FALSE\n#> 20   77      down       Blinky         FALSE\n#> 21   81      down  Blinky_weak          TRUE\n#> 22   85      down  Blinky_weak          TRUE\n#> 23   89      left Blinky_eaten          TRUE\n#> 24   93     right Blinky_eaten          TRUE\n#> 25   97    middle Blinky_eaten          TRUE\n#> 26  101    middle Blinky_eaten          TRUE\n#> 27  105     right Blinky_eaten          TRUE\n#> 28  109        up Blinky_eaten          TRUE\n#> 29  113     right Blinky_eaten         FALSE\n#> 30  117        up Blinky_eaten         FALSE\n#> 31  121     right Blinky_eaten         FALSE\n#> 32  125        up Blinky_eaten         FALSE\n#> 33  129     right Blinky_eaten         FALSE\n#> 34  133        up Blinky_eaten         FALSE\n#> 35  137     right Blinky_eaten         FALSE\n#> 36  141        up Blinky_eaten          TRUE\n#> 37  145        up Blinky_eaten          TRUE\n#> 38  149    middle Blinky_eaten          TRUE\n#> 39  153    middle Blinky_eaten          TRUE\n#> 40  157    middle Blinky_eaten          TRUE\n#> 41  161        up       Blinky          TRUE\n#> 42  165        up       Blinky          TRUE\n#> 43  169     right       Blinky          TRUE\n#> 44  173     right       Blinky         FALSE\n#> 45  177     right       Blinky         FALSE\n#> 46  181      down       Blinky         FALSE\n#> 47  185      down       Blinky         FALSE\n#> 48  189      down       Blinky         FALSE\n#> 49  193      down       Blinky         FALSE\n#> 50  197      down       Blinky         FALSE\n#> 51  201      down       Blinky         FALSE\n#> 52  205      down       Blinky         FALSE\n#> 53  209      down       Blinky         FALSE\n#> 54  213      left       Blinky         FALSE\n#> 55  217      left  Blinky_weak          TRUE\n#> 56  221      down  Blinky_weak          TRUE\n#> 57  225      down  Blinky_weak          TRUE\n#> 58  229     right  Blinky_weak          TRUE\n#> 59  233     right  Blinky_weak          TRUE\n#> 60  237     right  Blinky_weak          TRUE\n#> 61  241     right  Blinky_weak          TRUE\n#> 62  245    middle  Blinky_weak          TRUE\n#> 63  249      down       Blinky         FALSE\n#> 64  253      down       Blinky         FALSE\n#> 65  257      down       Blinky         FALSE\n#> 66  261     right       Blinky         FALSE\n#> 67  265     right       Blinky         FALSE\n#> 68  269        up       Blinky         FALSE\n#> 69  273        up       Blinky         FALSE\n#> 70  277        up       Blinky         FALSE\n#> 71  281    middle       Blinky         FALSE\n#> 72  285     right       Blinky         FALSE\n#> 73  289     right       Blinky         FALSE\n#> 74  293        up       Blinky         FALSE\n#> 75  297        up       Blinky         FALSE\n```\n:::\n\n\nTo simplify a little, below a small example of a ghost moving in one direction with predetermined states.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_ghost <- bind_rows(\n  tibble(x = 1:4, y = 0, colour = \"Blinky\"),\n  tibble(x = 5:8, y = 0, colour = \"Blinky_weak\"),\n  tibble(x = 9:12, y = 0, colour = \"Blinky_eaten\")\n)\nblinky_moves <- ggpacman::compute_ghost_coord(blinky_ghost)\n```\n:::\n\n\n\n::: {.cell}\n\n```\n#> # A tibble: 48 Ã— 12\n#>    colour    X0    Y0 state_x state_y direction state  step noise_x   noise_y\n#>    <chr>  <int> <dbl>   <dbl>   <dbl> <chr>     <int> <int>   <dbl>     <dbl>\n#>  1 Blinky     1     0      NA      NA middle        1     1  0.0435 -0.0111  \n#>  2 Blinky     1     0      NA      NA middle        2     2  0.0140 -0.0254  \n#>  3 Blinky     1     0      NA      NA middle        3     3 -0.0251 -0.0600  \n#>  4 Blinky     1     0      NA      NA middle        4     4 -0.0335  0.147   \n#>  5 Blinky     2     0       1       0 right         1     5 -0.0653 -0.0104  \n#>  6 Blinky     2     0       1       0 right         2     6  0.0131 -0.0278  \n#>  7 Blinky     2     0       1       0 right         3     7  0.0170  0.0251  \n#>  8 Blinky     2     0       1       0 right         4     8  0.0501  0.0718  \n#>  9 Blinky     3     0       1       0 right         1     9 -0.0250 -0.000805\n#> 10 Blinky     3     0       1       0 right         2    10  0.0346 -0.112   \n#> # â„¹ 38 more rows\n#> # â„¹ 2 more variables: body <list>, eyes <list>\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblinky_plot <- base_layer +\n  coord_fixed(xlim = c(0, 13), ylim = c(-1, 1)) +\n  geom_polygon(\n    data = unnest(blinky_moves, \"body\"),\n    mapping = aes(x = x, y = y, fill = colour, colour = colour, group = step),\n    inherit.aes = FALSE\n  ) +\n  geom_circle(\n    data = unnest(blinky_moves, \"eyes\"),\n    mapping = aes(x0 = x0, y0 = y0, r = r, colour = part, fill = part, group = step),\n    inherit.aes = FALSE\n  )\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/blinky-plot-line-1.png){width=355.2}\n:::\n:::\n\n\nI am sure, you remember all the colours and their mapped values from the beginning, so you probably won't need the following to understand of the ghost disappeared.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"Blinky\" = \"red\", \"Blinky_weak\" = \"blue\", \"Blinky_eaten\" = \"transparent\",\n```\n:::\n\n\n*Note: yes, `\"transparent\"` is a colour and a very handy one.*\n\nA new animation to see our little Blinky in action?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimated_blinky <- blinky_plot + transition_manual(step)\n```\n:::\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/blinky-state-plot-animated-1.gif)\n:::\n:::\n\n\n## Plot time\n\nIn the current version, nearly everything is either a dataset or a function and could be used like this.\n\n### Load and compute the data\n  \n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"pacman\", package = \"ggpacman\")\ndata(\"maze_points\", package = \"ggpacman\")\ndata(\"maze_walls\", package = \"ggpacman\")\ndata(\"blinky\", package = \"ggpacman\")\ndata(\"pinky\", package = \"ggpacman\")\ndata(\"inky\", package = \"ggpacman\")\ndata(\"clyde\", package = \"ggpacman\")\nghosts <- list(blinky, pinky, inky, clyde)\npacman_moves <- ggpacman::compute_pacman_coord(pacman)\nbonus_points_eaten <- ggpacman::compute_points_eaten(maze_points, pacman_moves)\nmap_colours <- c(\n  \"READY!\" = \"goldenrod1\",\n  \"wall\" = \"dodgerblue3\", \"door\" = \"dodgerblue3\",\n  \"normal\" = \"goldenrod1\", \"big\" = \"goldenrod1\", \"eaten\" = \"black\",\n  \"Pac-Man\" = \"yellow\",\n  \"eye\" = \"white\", \"iris\" = \"black\",\n  \"Blinky\" = \"red\", \"Blinky_weak\" = \"blue\", \"Blinky_eaten\" = \"transparent\",\n  \"Pinky\" = \"pink\", \"Pinky_weak\" = \"blue\", \"Pinky_eaten\" = \"transparent\",\n  \"Inky\" = \"cyan\", \"Inky_weak\" = \"blue\", \"Inky_eaten\" = \"transparent\",\n  \"Clyde\" = \"orange\", \"Clyde_weak\" = \"blue\", \"Clyde_eaten\" = \"transparent\"\n)\n```\n:::\n\n\n### Build the base layer with the maze\n   \n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid <- ggplot() +\n  theme_void() +\n  theme(\n    legend.position = \"none\",\n    plot.background = element_rect(fill = \"black\", colour = \"black\"),\n    panel.background = element_rect(fill = \"black\", colour = \"black\")\n  ) +\n  scale_size_manual(values = c(\"wall\" = 2.5, \"door\" = 1, \"big\" = 2.5, \"normal\" = 0.5, \"eaten\" = 3)) +\n  scale_fill_manual(breaks = names(map_colours), values = map_colours) +\n  scale_colour_manual(breaks = names(map_colours), values = map_colours) +\n  coord_fixed(xlim = c(0, 20), ylim = c(0, 26)) +\n  geom_segment(\n    data = maze_walls,\n    mapping = aes(x = x, y = y, xend = xend, yend = yend, size = type, colour = type),\n    lineend = \"round\",\n    inherit.aes = FALSE\n  ) +\n  geom_point(\n    data = maze_points,\n    mapping = aes(x = x, y = y, size = type, colour = type),\n    inherit.aes = FALSE\n  ) +\n  geom_text(\n    data = tibble(x = 10, y = 11, label = \"READY!\", step = 1:20),\n    mapping = aes(x = x, y = y, label = label, colour = label, group = step),\n    size = 6\n  )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-grid-final-1.png){width=672}\n:::\n:::\n\n\n### Draw the `\"eaten\"` bonus points geometry\n   \n\n::: {.cell}\n\n```{.r .cell-code}\np_points <- list(\n  geom_point(\n    data = bonus_points_eaten,\n    mapping = aes(x = x, y = y, colour = colour, size = colour, group = step),\n    inherit.aes = FALSE\n  )\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid + p_points\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-grid-points-final-1.png){width=672}\n:::\n:::\n\n\n### Draw the main character (I am talking about Pac-Man ...)\n   \n\n::: {.cell}\n\n```{.r .cell-code}\np_pacman <- list(\n  geom_arc_bar(\n    data = pacman_moves,\n    mapping = aes(\n      x0 = x, y0 = y,\n      r0 = 0, r = 0.5,\n      start = start, end = end,\n      colour = colour, fill = colour,\n      group = step\n    ),\n    inherit.aes = FALSE\n  )\n)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid + p_pacman\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-grid-pacman-final-1.png){width=672}\n:::\n:::\n\n\n### Draw the ghosts, using the trick that `+` works also on a list of geometries\n  \n\n::: {.cell}\n\n```{.r .cell-code}\np_ghosts <- map(.x = ghosts, .f = function(data) {\n  ghost_moves <- compute_ghost_status(\n    ghost = data,\n    pacman_moves = pacman_moves,\n    bonus_points_eaten = bonus_points_eaten\n  )\n  list(\n    geom_polygon(\n      data = unnest(ghost_moves, \"body\"),\n      mapping = aes(\n        x = x, y = y,\n        fill = colour, colour = colour,\n        group = step\n      ),\n      inherit.aes = FALSE\n    ),\n    geom_circle(\n      data = unnest(ghost_moves, \"eyes\"),\n      mapping = aes(\n        x0 = x0, y0 = y0,\n        r = r,\n        colour = part, fill = part,\n        group = step\n      ),\n      inherit.aes = FALSE\n    )\n  )\n})\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid + p_ghosts\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/base-grid-ghosts-final-1.png){width=672}\n:::\n:::\n\n\n### Draw everything\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nbase_grid + p_points + p_pacman + p_ghosts\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-time-all-1.png){width=672}\n:::\n:::\n\n\n### Animate everything\n   \n\n::: {.cell}\n\n```{.r .cell-code}\nPacMan <- base_grid + p_points + p_pacman + p_ghosts + transition_manual(step)\n```\n:::\n\n\n\n\n::: {.cell .hcenter}\n::: {.cell-output-display}\n![](index_files/figure-html/plot-time-all-animated-1.gif)\n:::\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}